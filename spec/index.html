<!DOCTYPE html>
<html>
  <head>
    <title>
      Accessibility Object Model
    </title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async
    class='remove'>
    </script>
    <script class='remove'>
    /*Make tidy happy*/
    var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "aom",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alice Boxhall"
              ,   url:        "http://google.com"
              ,   mailto:     "aboxhall@google.com"
              ,   company:    "Google"
              ,   companyURL: "http://google.com/"
              },
              {
                  name:       "Bogdan Brinza"
              ,   url:        "http://microsoft.com"
              ,   mailto:     "bbrinza@microsoft.com"
              ,   company:    "Microsoft"
              ,   companyURL: "http://microsoft.com/"
              },
              {
                  name:       "James Craig"
              ,   url:        "http://apple.com"
              ,   mailto:     "jcraig@apple.com"
              ,   company:    "Apple"
              ,   companyURL: "http://apple.com/"
              },
              {
                  name:       "Dominic Mazzoni"
              ,   url:        "http://google.com"
              ,   mailto:     "dmazzoni@google.com"
              ,   company:    "Google"
              ,   companyURL: "http://google.com/"
              },
              {
                  name:       "Cynthia Shelley"
              ,   url:        "http://microsoft.com"
              ,   mailto:     "cyns@microsoft.com"
              ,   company:    "Microsoft"
              ,   companyURL: "http://microsoft.com/"
              },
              {
                  name:       "Alexander Surkov"
              ,   url:        "http://mozilla.org/"
              ,   mailto:     "surkov.alexander@gmail.com"
              ,   company:    "Mozilla"
              ,   companyURL: "http://mozilla.org/"
              },
          ],
          // name of the WG
          //         wg:           "None",

          // URI of the public WG page
          //         wgURI:        "http://example.org/really-cool-wg",

          // name (without the @w3c.org) of the public mailing to which comments are due
          //          wgPublicList: "spec-writers-anonymous",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          //        wgPatentURI:  "",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
    <style>
      table{
        border:solid 2px #999;
        border-width:1px 0 0 1px;
        margin:0.1em 0 1em;
        padding:0;
        border-spacing:0;
        border-collapse:collapse;
      }
      th, td{
        border:solid 2px #999;
        border-width:0 1px 1px 0;
        padding:0.15em 0.3em 0.1em;
        /*min-width:20em;*/
        vertical-align:top;
        text-align:left;
      }
      th+th, td+td{
        width:auto;
      }
      th{
        background-color:#eee;
      }
      caption{
        text-align:left;
        color:#555;
        font-style:normal;
        margin:1em 0 0.1em;
        padding:0 0 0 0.3em;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        The web platform has a long history of features for developers
        to use to make their web content more accessible to users with
        disabilities, from the <code>alt</code> attribute on images to
        all of [[!WAI-ARIA]]. A key component of these solutions is
        that user agents provide an alternate way to interact with a
        web app using native accessibility APIs specific to each
        platform. These APIs are used by a variety of assistive
        technologies, including but not limited to screen readers and
        magnifiers for visually impaired users, and switch access
        software and voice control software for motor-impaired
        users. Accessibility APIs are also often used for automation
        and automated testing.
      </p>
      <p>
        Increasingly, apps that take full advantage of some new web
        platform features are finding it difficult or impossible to
        make their apps accessible. In particular, one of the biggest
        challenges happens when a web app uses scripting, and not
        declarative markup, for a significant portion of its user
        interface - for example building a portion of the interface
        using the HTML <code>canvas</code> element (both
        [[!2DCONTEXT]] and
        [[WEBGL]]). Authors are forced to create fake invisible DOM
        elements that represent accessible objects on the screen, a
        hack that's cumbersome, limited, and ultimately bad for the
        platform.
      </p>
      <p>
        Authors also face challenges when using the [[!SHADOW-DOM]],
        because it isn't possible to use ARIA relations like
        <code>aria-activeDescendant</code> or <code>aria-labelledby</code>
        when the target element is inside the shadow DOM of another
        element.
      </p>
      <p>
        The solution is to make it possible for an author to make an
        app accessible using scripting, where desirable, rather than
        the only option being accessible features of HTML markup. In a
        simple use case, the author is able to set an
        accessibility attribute of an HTML element via JavaScript
        without affecting that element's HTML attributes. In a more
        complicated use case, the author is able to create new
        virtual accessible objects on the page that don't correspond
        to an HTML element at all, such as controls in a Canvas-based
        app.
      </p>
      <p>
        This spec is narrowly focused on the goal of creating a
        scripting API for web accessibility. It's intended to
        complement existing web accessibility APIs such as
        [[!WAI-ARIA]], not replace them. In particular, this spec
        attempts to avoid proposing new roles, states, and properties
        an accessible object can have except where necessary;
        otherwise it just defines a mechanism by which an accessible
        object with those same roles, states and properties can be
        defined without necessarily being tied to the HTML DOM.
      </p>
    </section>
    <section>
      <h2>
        Introduction
      </h2>
      <p>
        <em>This section is non-normative.</em>
      </p>
      <p>
        This API is called the Accessibility Object Model because it's based
        around the idea that all modern operating systems, including
        both desktop and mobile operating systems, have native APIs that
        allow an application to be explored and controlled via a high-level
        semantic interface for the purposes of accessibility or automation.
        A key component of these interfaces across all platforms is that
        they represent each application's user interface as a tree of
        accessible objects.
      </p>
      <p>
        The canonical example of a client of accessibility APIs is a
        <i>screen reader</i> used by blind users to access a computer or
        mobile device using synthesized speech or braille. Other examples
        include magnifiers, voice control software, and switch access software,
        plus testing and automation tools. All of these accessibility
        clients can do three things:
        <ol>
          <li>Explore the tree of accessible objects representing the
            current state of the application's user interface,
          <li>Listen for notifications from the application when the
            user interface has changed, and
          <li>Control the interface by commanding it to set focus,
            activate a control, enter text, and more.
        </ol>
      </p>
      <p>
        Web browsers have long had support for accessibility APIs,
        allowing all sorts of assistive technology and testing tools
        access to everything in a web page. The HTML standard defined
        attributes such as <code>alt</code> that allow the HTML author
        to provide an accessible text alternative for an image.
      </p>
      <p>
        As the web became used more for applications and not just documents,
        the [[!WAI-ARIA]] standard was created to allow web authors to
        fill in missing semantics in the accessibility tree.
      </p>
      <p>
        A fundamental assumption of [[!WAI-ARIA]], though, is that there's
        essentially a one-to-one correspondence between a DOM element
        and an accessible node. While there are ways to hide
        presentational DOM elements from the accessibility tree, there are
        no ways to create accessible nodes that don't correspond to
        DOM elements. This is one of the gaps this spec aims to address.
      </p>
      <section class="informative">
        <h3>
          Terms
        </h3>
        <p>
          An <dfn>Accessibility Tree</dfn> is a semantic representation of an
          application's user interface enabling it to be observed and
          controlled by other client software programs, like <dfn>assistive
          technology</dfn> and automation software, via a platform-native
          <dfn>Accessibility API</dfn>. User agents typically provide
          support for one or more native accessibility APIs.
        </p>
        <p>
          The Accessibility Tree is made up of
          <a href="#accessiblenode"><dfn>Accessible Nodes</dfn></a>.
          Accessible Nodes have a <dfn>role</dfn> and several <a href="#attributes">
          <dfn>Accessibility Attributes</dfn></a> that describe the node's
          characteristics and its current state.
        </p>
        <p>
          In many cases, the Accessibility Tree exposed by a user
          agent corresponds closely to a web page's DOM tree, with one
          Accessible Node for every DOM Node. However, sometimes the
          trees need to differ - for example, several DOM elements may
          create a media player seek control, but in the Accessibility
          Tree that whole collection might be represented by a single
          Accessible Node with a role of <code>"slider"</code> and
          other attributes indicating its min, max, and current value.
        </p>
        <p>
          When assistive technology users control an application via its
          accessibility API, they generate <dfn>accessibility input events</dfn>.
          Accessiblity input events often imply specific user intents that
          can't be easily captured by apps in a universal, cross-platform
          way. For example, there is a specific accessibility input event
          to increment a slider. On a desktop platform this might be the
          equivalent of the right-arrow key, but while several mobile
          screen readers provide a touch-screen gesture to increment a slider,
          it isn't standard across platforms and there's no straightforward
          way for an author to detect it.
        </p>
      </section>
    </section>

    <section>
      <h2>
        Tutorial
      </h2>
      <p>
        <em>This section is non-normative.</em>
      </p>
      <section>
        <h3>
          Getting an AccessibleNode from a DOM Node
        </h3>
        <p>
          In the Accessibility Object Model, every DOM node on a page
          has an associated AccessibleNode that can be retrieved using the
          <code>accessibleNode</code> property. The following example shows a
          snippet of HTML for a heading along with the code to obtain
          the accessible node for it.
        </p>
        <pre class="example highlight">
          &lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
          &lt;script&gt;
            var contents = document.getElementById("contents");
            var axContents = contents.accessibleNode;
          &lt;/script&gt;</pre>
        </div>
        <p>
          Accessing the properties of the resulting object returns
          computed accessibility attributes of the DOM element, such as
          its role, level, and label:
        </p>
        <pre class="example highlight">
          axContents.role;   // returns "heading"
          axContents.level;  // returns 2 since it's a H2 element
          axContents.label;  // returns "Contents"
        </pre>
      </section>
      <section>
        <h3>
          Modifying accessibility attributes
        </h3>
        <p>
          Most properties on an AccessibleNode can be modified. If you're
          familiar with [[!WAI-ARIA]] attributes, you'll recognize most of
          the properties and their legal values. Let's take the example
          above and change the role and label.
        </p>
        <pre class="example highlight">
          axContents.role = "region";
          axContents.label = "Table of contents";
        </pre>
        <p>
          Changing a property immediately affects the accessibility
          tree and the browser notifies any accessibility clients about
          the change. On an AccessibleNode, instead of several attributes
          that affect the computed name, a single property,
          <code>label</code>, determines its accessible name and it
          overrides any accessible text from the DOM.
        </p>
        <p>
          Setting the value of a property to <code>undefined</code>
          will have the effect of reverting any user-modified value
          and the property will have its computed value instead:
        </p>
        <pre class="example highlight">
          axContents.role = "region";
          axContents.role;  // Returns "region"

          axContents.role = undefined;
          axContents.role;  // Returns "heading"
        </pre>
        <p>
          Setting the value of a property to an illegal value will
          have the same effect as setting it to <code>undefined</code>,
          it will revert any user-modified value. This is useful as
          a form of feature detection.
        </p>
        <pre class="example highlight">
          axContents.role = "butler";
          axContents.role;  // Returns "heading", because "butler" is not a valid role.
        </pre>
      </section>
      <section>
        <h3>
          Optional properties
        </h3>
        <p>
          Some properties of AccessibleNode are optional, they are allowed to be
          null. For example, <code>rangeValue</code> only applies to elements
          with certain roles (like "slider" and "progressbar").
          Other properties of AccessibleNode apply to all elements
          and are never null, for example <code>focusable</code> must always be
          true or false.
        </p>
      </section>
      <section>
        <h3>
          Relation properties
        </h3>
        <p>
          Some properties express relationships between one AccessibleNode
          and one or more others, for example, <code>activeDescendant</code>
          and <code>labelledBy</code>. The semantics of these relationships
          are basically the same as their corresponding ARIA attributes. In ARIA, a
          relationship can only be expressed with an IDREF, i.e. by passing
          the ID of another element in the Document. With the
          AccessibleNode interface, it isn't necessary for the target
          element to have an ID. Furthermore, it isn't necessary for
          the the target element to be in the same Document, as long as
          it is from the same origin. This means it's possible to reference
          an element in an iframe from the same site, or an element inside
          shadow DOM. In the example below, a listbox sets its activeDescendant
          without putting an ID on any of the options.
        </p>
        <pre class="example highlight">
          &lt;div role="listbox"&gt;
            &lt;div role="option"&gt;Kirk&lt;/div&gt;
            &lt;div class="selected" role="option"&gt;Picard&lt;/div&gt;
          &lt;/div&gt;
          &lt;script&gt;
            var listbox = document.querySelector("[role='listbox']");
            var axListbox = listbox.accessibleNode;
            var selectedOption = listbox.querySelector(".selected");
            axListbox.activeDescendant = selectedOption.accessibleNode;
          &lt;/script&gt;</pre>
        </div>
      </section>
      <section>
        <h3>
          Exploring the accessibility tree
        </h3>
        <p>
          From any AccessibleNode, you can explore the rest of the
          accessibility tree using the <code>children</code>
          and <code>parent</code> properties, as in this example.
        </p>
        <pre class="example highlight">
          &lt;ol id="list1"&gt;
            &lt;li&gt;The Original Series&lt;/li&gt;
            &lt;li&gt;The Next Generation&lt;/li&gt;
            &lt;li&gt;Deep Space Nine&lt;/li&gt;
            &lt;li&gt;Voyager&lt;/li&gt;
            &lt;li&gt;Enterprise&lt;/li&gt;
          &lt;/ol&gt;
          &lt;script&gt;
            var axList = document.getElementById("list1").accessibleElement;
            var axItem1 = axList.children[0];
            var axItem2 = axList.children[1];
            axItem1.parent == axList;  // returns true;
          &lt;/script&gt;</pre>
        </pre>
      </section>
      <section>
        <h3>
          Rearranging the accessibility tree
        </h3>
        <p>
          The Accessibility Object Model lets you arbitrarily rearrange
          nodes in the accessibility tree without affecting the DOM tree.
          For example, you can remove the first list item from the example
          above and put it at the end of the list instead:
        </p>
        <pre class="example highlight">
          axList.children.remove(0);
          axList.append(axItem1);
        </pre>
      </section>
      <section>
        <h3>
          Creating new "virtual" accessible nodes
        </h3>
        <p>
          A virtual AccessibleNode can be created that does not correspond to
          a DOM node. This is intended to be used to represent an object on the screen
          that's drawn using some other mechanism, such as an HTML Canvas.
          The AccessibleNode constructor takes a single argument that
          initializes the new object's role.
        </p>
        <pre class="highlight example">
          var axVirtualButton = new AccessibleNode("button");
          axVirtualButton.label = "Enable Audio Descriptions";
          axVirtualButton.offsetWidth = 224;
          axVirtualButton.offsetHeight = 72;
        </pre>
        <p>
          A virtual AccessibleNode isn't part of the document's
          accessibility tree until it's added as the child of another element.
          For example, this code would add the virtual button we created
          above as a child of the HTML body element's accessible node:
        </p>
        <pre class="highlight example">
          document.body.accessibleNode.children.append(axVirtualButton);
        </pre>
        <p>
          Modifying the <code>children</code> or <code>parent</code>
          attributes an be used to rearrange any elements in the
          accessibility tree for a document, including those that are
          backed by DOM Nodes. If the elements in the HTML DOM are not
          in the proper order for accessibility, this can be
          used to rearrange the accessibility tree so that it's
          correct semantically.
        </p>
        <p>
          When making a change to the accessibility tree, the node
          being moved is automatically detached from its previous
          location if it was already in the accessibility tree. It's
          not necessary to remove it first. Because of this, it's not
          possible to accidentally create a cycle - if you add B as a
          child of A, and then try to add A as a child of B, that
          second step would have the effect of detaching A from its
          parent and the end result would be that A is a child of B,
          but both are detached from the document's accessibility
          tree.
        </p>
        <p>
          The only case where it's illegal to add an AccessibleNode as the
          child of another is if it's backed by a DOM element that comes from
          a different Document. That will raise an exception. The
          accessibility tree can only be rearranged within one Document.
        </p>
      </section>
      <section>
        <h3>
          Accessibility input events
        </h3>
        <p>
          AccessibleNodes are EventTargets and you can register event
          listeners for special accessibility input events that come
          from assistive technology. This is critical when building a
          virtual accessible node in order to make it interactive at
          all, but it can also be helpful for DOM-backed accessible
          nodes because there are some accessible input events that
          can be generated by assistive technology and have a clear
          semantic intent, like <em>increment</em> or
          <em>dismiss</em>, and can't be detected by other means.
        </p>
        <p>
          This example adds a virtual button to the pgae and registers
          a click listener on it.
        </p>
        <pre class="highlight example">
          var axVirtualButton = new AccessibleNode("button");
          axVirtualButton.label = "Enable Audio Descriptions";
          axVirtualButton.offsetWidth = 224;
          axVirtualButton.offsetHeight = 72;
          axVirtualButton.addEventListener("accessibleclick", function(event) {
            alert("clicked!");
          }, false);
          document.body.accessibleNode.appendChild(axVirtualButton);
        </pre>
        <p>
          Virtual accessible nodes can be focusable, but they'll never be
          part of the tab order. It's up to the author to track focus
          in virtual accessible nodes.
        </p>
      </section>
    </section>

    <section>
      <h2>
        Interfaces
      </h2>
      <section>
        <h3>
          Extensions to the <code>Node</code> interface
        </h3>
        <p>
          The author can request an <a>accessible node</a> from any [[!DOM]]
          <code>Node</code> that is rendered as part of a web page.
        </p>
        <pre class="idl">
          partial interface Node {
            readonly attribute AccessibleDOMNode? accessibleNode;
          };
        </pre>
        <p>
          The <code>accessibleNode</code> attribute returns the <a>accessible
          node</a> associated with this <code>DOM node</code>, or
          <code>null</code> if this DOM node is not currently rendered as
          part of a web page.
        </p>
      </section>
      <section id="accessiblenode">
        <h3>
          <code>AccessibleNode</code> and <code>AccessibleDOMNode</code> interfaces
        </h3>
        <p>
          An AccessibleNode is an interface that represents one node
          in the user agent's accessibility tree. A subclass,
          AccessibleDOMNode, can be retrieved directly from a DOM
          Node, or a new AccessibleNode can be constructed and
          inserted into the accessibility tree.
        </p>
        <pre class="idl">
        [Constructor(DOMString role)]
        interface AccessibleNode : EventTarget {
          attribute DOMString role;

          void setAttribute(DOMString attributeName, any value);
          any getAttribute(DOMString attributeName);

          void setRelation(DOMString relationName, any relatives);
          any getRelation(DOMString relationName);

          void focus();
          void announce(DOMString message);
        };

        interface AccessibleDOMNode : AccessibleNode {
          readonly attribute Node node;
        };
        </pre>
        <p>
          The AccessibleNode constructor, when called, returns a new
          empty AccessibleNode object with its role initialized to
          the provided value. The AccessibleNode has no associated
          DOM Node and is not attached to the document's accessibility
          tree, it must be explicitly added as a child of another
          AccessibilityNode.
        </p>
        <p id="source">
          Let an AccessibleNode's <dfn>source</dfn> be an internal
          dictionary containing attributes that the author has set.
          Attributes in an AccessibleNode's <em>source</em>, when valid,
          supercede all other rules in the computation of that attribute.
        </p>
        <p>
          The <dfn>role</dfn> attribute, on setting, stores the provided
          DOMString in the AccessibleNode's <dfn>source</dfn>.
          On getting, it runs the following algorithm:
          <ul>
            <li>If the AccessibleNode's source contains a valid <dfn>role</dfn>
              according to the [[!WAI-ARIA]] spec, return that role.
            <li>Otherwise, if this is an AccessibleDOMNode and its associated
              DOM node has a valid <dfn>role</dfn> attribute according to the
              [[!WAI-ARIA]] spec, return that role.
            <li>Otherwise, if this is an AccessibleDOMNode, return the
              <dfn>computed role</dfn> for this node according to the
              [[!HTML-AAM-1.0]] spec.
            <li>Otherwise, return the empty string.
          </ul>
        </p>
        <p>
          The <dfn>setAttribute</dfn> method, when called with the
          name of an <a href="#attribute">accessibility attribute</a>,
          stores the provided value in the AccessibleNode's
          <a href="#source">source</a>.
        </p>
        <p>
          The <dfn>getAttribute</dfn> method, when called with the
          name of an <a href="#attribute">accessibility attribute</a>,
          runs the following algorithm:
          <ul>
            <li>If this attribute is not defined for the AccessibleNode's
              <dfn>role</dfn>, return <code>undefined</code>.
            <li>If the AccessibleNode's source contains a valid value
              for this attribute, returns that value.
            <li>Otherwise, if this is an AccessibleDOMNode, return the
              computed value of this attribute according to the
              algorithm associated with this attribute.
            <li>Otherwise, return the default value for this
              attribute, which may be <code>undefined</code>.
          </ul>
        </p>
        <p>
          For each supported <a href="#attribute">accessibility
            attribute</a>, the following partial interface applies.
          <pre class="idl">
            partial interface AccessibleNode {
              attribute <em>typename</em> attributeName;
            };</pre>
          Setting the attribute must invoke setAttribute() with the first
          argument being the attribute name, and the second argument the
          given value.  Getting the attribute must invoke getAttribute()
          with the argument being the attribute name, and return the result.
        </p>
        <p>
          The <dfn>setRelation</dfn> method, when called with the
          name of an <a href="#relations">relationship attribute</a>,
          stores the provided value in the AccessibleNode's
          <a href="#source">source</a>.
        </p>
        <p>
          If the type of the relation attribute
          is <code>AccessibleNode</code>, then only an
          <code>AccessibleNode</code> will be valid, and setting it
          to any other value will have the same effect as clearing that
          relationship attribute in the source.
        </p>
        <p>
          If the type of the relation attribute
          is <code>AccessibleNodeList</code>, then either an
          <code>AccessibleNode</code>, a
          <code>AccessibleNodeList</code>, or any sequence or iterable
          of <code>AccessibleNodes</code> will be valid and converted
          to an <code>AccessibleNodeList</code> automatically, and
          setting it to any other value will have the same effect as
          clearing that relationship attribute in the source.
        </p>
        <p>
          Most relationship attributes have a reciprocal relationship
          attribute that expresses the inverse relationship. For example,
          the inverse of <code>children</code> is <code>parent</code>,
          and the inverse of <code>labelledBy</code> is <code>labelFor</code>.
          When a relationship attribute is set, the target's corresponding
          reciprocal relationship attribute is set automatically.
        </p>
        <p>
          Setting a relationship attribute often implies clearing a
          previously existing relationship. This also happend automatically
          when a relationship attribute is set.
        </p>
        <p>
          The <dfn>getRelation</dfn> method, when called with the
          name of an <a href="#relations">relationship attribute</a>,
          runs the following algorithm:
          <ul>
            <li>If the AccessibleNode's source contains a valid value
              for this attribute, returns that value.
            <li>Otherwise, if this is an AccessibleDOMNode, return the
              computed value of this attribute according to the
              algorithm associated with this attribute.
            <li>Otherwise, if the relationship attribute's type is
              <code>AccessibleNode</code>, return null, but if the
              type is <code>AccessibleNodeList</code>, return a
              reference to the empty <code>AccessibleNodeList</code>
              from its source, which can be modified dynamically by the
              caller.
          </ul>
        </p>
        <p>
          For each supported <a href="#relations">relationship
          attribute</a>, the following partial interface applies.
          <pre class="idl">
            partial interface AccessibleNode {
              attribute <em>typename</em> relationName;
            };</pre>
          Setting the attribute must invoke setRelation() with the first
          argument being the attribute name, and the second argument the
          given value.  Getting the attribute must invoke getRelation()
          with the argument being the attribute name, and return the result.
        </p>
        <p>
          The <dfn>focus</dfn> method, when called, changes the node
          that is reported as the focused node within the accessibility
          tree, without changing input focus in the DOM. This focused
          state will persist until DOM input focus changes, then
          that DOM node's AccessibleNode will become focused.
        </p>
        <p>
          The <dfn>announce</dfn> method, when called, sends an
          announcement message to assistive technology. A screen reader
          may speak the given message to the user, for example.
          If a string is passed as the argument, that string is used as
          the announcement message, otherwise the accessible name of the
          target node is used as the message text. Authors are
          encouraged to call this method on the most appropriate
          node on the screen because some assistive technology might
          visually highlight the node making the announcement.
        </p>
      </section>
      <section>
        <h3>
          <code>AccessibleNodeList</code> interface
        </h3>
        <p>
          Relationship attributes allow expressing
          a relationship between one AccessibleNode and an ordered
          list of other nodes. This list can be expressed using an
          <dfn>AccessibleNodeList</dfn>.
        </p>

        <pre class="idl">
        interface AccessibleNodeList {
          readonly attribute unsigned long length;

          void clear();
          getter AccessibleNode? getNode(unsigned long index);
          AccessibleNode insertBefore(AccessibleNode newNode, unsigned long index);
          AccessibleNode replace(AccessibleNode newNode, unsigned long index);
          AccessibleNode remove(unsigned long index);
          AccessibleNode remove(AccessibleNode node);
          AccessibleNode append(AccessibleNode newNode);
          setter void (unsigned long index, AccessibleNode newNode);

          iterable&lt;AccessibleNode&gt;;
        };
        </pre>

      </section>
    </section>

    <section id="attributes">
      <h2>
        Accessibility attributes
      </h2>
      <p>
        An <dfn>Accessibility Attribute</dfn> is an abstract concept that is not
        exposed as an object in the DOM. An Accessibility Attribute has
        the following associated properties:
      </p>
      <dl>
        <dt>name</dt>
        <dd>The name of the attribute.</dd>
        <dt>type</dt>
        <dd>The data type that values of this attribute take</dd>
        <dt>settable</dt>
        <dd>Whether this value can be set on an AccessibleNode or
          if it's read-only.</dd>
        <dt>supported roles</dt>
        <dd>A list of roles on which this attribute is allowed to be set</dd>
        <dt>related ARIA attribute</dt>
        <dd>The corresponding ARIA attribute, if any</dd>
        <dt>computed value algorithm</dt>
        <dd>The algorithm used to compute the value of this attribute,
          when not explicitly set on an AccessibleNode.</dd>
      </dl>
      <p>
        AccessibleNodes support the following accessibility attributes:
      </p>
      <table>
        <caption>
          Accessibility attribute table
        </caption>
        <thead>
          <tr>
            <th>attribute name</th>
            <th>type</th>
            <th>default value</th>
            <th>settable</th>
            <th>supported roles</th>
            <th>related ARIA attributes</th>
            <th>computed value algorithm</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>autocomplete</code></td>
            <td><code>enum { "both", "inline", "list", "none" }</code></td>
            <td><code>"none"</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-autocomplete</nobr></code></td>
            <td><code><nobr>aria-autocomplete</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>colCount</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-colcount</nobr></code></td>
            <td><code><nobr>aria-colcount</nobr></code></td>
            <td>
              The value of <code><nobr>aria-colcount</nobr></code>,
              if any, otherwise the number of columns
              in a HTMLTableElement.
            </td>
          </tr>
          <tr>
            <td><code>colIndex</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-colindex</nobr></code></td>
            <td><code><nobr>aria-colindex</nobr></code></td>
            <td>
              The value of <code><nobr>aria-colindex</nobr></code>,
              if any, otherwise the index of the current
              column for any element with a cell role.
            </td>
          </tr>
          <tr>
            <td><code>colSpan</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-colspan</nobr></code></td>
            <td><code><nobr>aria-colSpan</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>description</code></td>
            <td><code>DOMString</code></td>
            <td><code>""</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td>
              The accessible description computation algorithm
              as defined in [[!ACCNAME-AAM-1.1]].
            </td>
          </tr>
          <tr>
            <td><code>disabled</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-disabled</nobr></code></td>
            <td><code><nobr>aria-disabled</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>expanded</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-expanded</nobr></code></td>
            <td><code><nobr>aria-expanded</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>focusable</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td>
              Returns true if an AccessibleDOMNode's associated
              DOM node is focusable.
            </td>
          </tr>
          <tr>
            <td><code>focused</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>readonly</td>
            <td><em>all roles</em></td>
            <td></td>
            <td>
              Returns true if an AccessibleNode is currently
              focused. Note that it's possible for this to not
              correspond to the DOM Node with input focus.
            </td>
          </tr>
          <tr>
            <td><code>hasPopUp</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-haspopup</nobr></code></td>
            <td><code><nobr>aria-haspopup</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>invalid</code></td>
            <td><code>enum { "grammar", "false", "spelling", "true" }</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-invalid</nobr></code></td>
            <td><code><nobr>aria-invalid</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>label</code></td>
            <td><code>DOMString</code></td>
            <td><code>""</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td>
              <code><nobr>aria-label</nobr></code>,
              <code><nobr>aria-labelledby</nobr></code>
            </td>
            <td>
              The accessible name computation algorithm
              as defined in [[!ACCNAME-AAM-1.1]].
            </td>
          </tr>
          <tr>
            <td><code>level</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-level</nobr></code></td>
            <td><code><nobr>aria-level</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>multiselectable</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-multiselectable</nobr></code></td>
            <td><code><nobr>aria-multiselectable</nobr></code></td>
            <td>
              Returns true if
              <code><nobr>aria-multiselectable</nobr></code> is set to true,
              or for an HTML <code>select</code> element with
              the <code>multi</code> attribute set.
            </td>
          </tr>
          <tr>
            <td><code>offsetLeft</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetTop</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetWidth</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetHeight</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>orientation</code></td>
            <td><code>enum { "horizontal", "vertical" } | undefined</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-orientation</nobr></code></td>
            <td><code><nobr>aria-orientation</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>placeholder</code></td>
            <td><code>DOMString?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-placeholder</nobr></code></td>
            <td><code><nobr>aria-placeholder</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>posInSet</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-posinset</nobr></code></td>
            <td><code><nobr>aria-posinset</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rangeValue</code></td>
            <td><code>double?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-valuenow</nobr></code></td>
            <td><code><nobr>aria-valuenow</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rangeMin</code></td>
            <td><code>double?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-valuemin</nobr></code></td>
            <td><code><nobr>aria-valuemin</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rangeMax</code></td>
            <td><code>double?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-valuemax</nobr></code></td>
            <td><code><nobr>aria-valuemax</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>readonly</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-readonly</nobr></code></td>
            <td><code><nobr>aria-readonly</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>required</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-required</nobr></code></td>
            <td><code><nobr>aria-required</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rowCount</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rowcount</nobr></code></td>
            <td><code><nobr>aria-rowcount</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rowIndex</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rowindex</nobr></code></td>
            <td><code><nobr>aria-rowindex</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rowSpan</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rowspan</nobr></code></td>
            <td><code><nobr>aria-rowspan</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>setSize</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-setsize</nobr></code></td>
            <td><code><nobr>aria-setsize</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>sort</code></td>
            <td><code>enum { "ascending", "descending", "none", "other" }</code></td>
            <td><code>"none"</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-sort</nobr></code></td>
            <td><code><nobr>aria-sort</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>value</code></td>
            <td><code>DOMString?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all widget roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>visible</code></td>
            <td><code>boolean</code></td>
            <td><code>true</code></td>
            <td>readonly</td>
            <td><em>all roles</em></td>
            <td>
              <code><nobr>aria-hidden</nobr></code>
            </td>
            <td>
              Returns true if an AccessibleDOMNode is not part of
              the accessibility tree because the DOM node is not
              visible or not displayed, or because the DOM node has
              the <code><nobr>aria-hidden</nobr></code> attribute set.
            </td>
          </tr>
        </tbody>
      </table>
      <section>
        <h3>
          Accessible names and descriptions
        </h3>
        <p>
          In web accessibility, every node in the accessibility
          tree has an <dfn>accessible name</dfn> and
          <dfn>accessible description</dfn>, which are computed
          using the algorithm described in [[!ACCNAME-AAM-1.1]].
          The name is primary, the description is secondary.
        </p>
        <p>
          There are many possible sources of the accessible name
          of an element from its declarative markup. As an example,
          an HTML INPUT element may get its accessible name from
          an associated LABEL element, from the <code>title</code>
          attribute, from the <code>aria-label</code>
          attribute, from the <code>aria-labelledby</code>
          attribute, or more. The [[!ACCNAME-AAM-1.1]] algorithm
          specifies exactly how these combine to form the final
          accessible name.
        </p>
        <p>
          When using the AccessibleNode interface, it's much simpler.
          The <code>label</code> attribute contains the accessible
          name and the <code>description</code> attribute contains
          the accessible description. In addition, the
          <code>labelledBy</code> attribute contains references to
          other accessible nodes that provided the label for a node,
          and the <code>describedBy</code> attribute contains
          references to other accessible nodes that provided
          the description, but those relation attributes are
          informational only.
        </p>
        <p>
          In particular, setting an AccessibleNode's
          <code>labelledBy</code> or <code>describedBy</code>
          attributes will have <em>no effect</em> on its
          accessible name or description. Set the
          <code>label</code> and <code>description</code>
          attributes directly if you want those to change.
        </p>
      </section>
      <section id="relations">
        <h2>
          Relationship attributes
        </h2>
        <p>
          In addition to attributes that express information about
          just one accessible node, an accessible node can also have
          <dfn>relationship attributes</dfn> that express
          relationships with other accessible nodes in the
          accessibility tree. Unlike their ARIA counterparts, the
          nodes referenced by relationship attributes do not need to
          have a unique ID. A relationship may be expressed between
          any two nodes whose <dfn>ancestor Documents</dfn> have the
          same origin.  This it is possible to express a relationship
          between a node in the main frame and a node in a child
          frame, or between a node in one element's shadow root and a
          different node in another element's shadow root, to name two
          specific examples.
        </p>
        <p>
          An <dfn>Accessibility Relationship Attribute</dfn> is an
          abstract concept that is not exposed as an object in the
          DOM. An Accessibility Attribute has the following associated
          properties:
        </p>
        <dl>
          <dt>name</dt>
          <dd>The name of the relationship.</dd>
          <dt>type</dt>
          <dd>Whether the value of the relationship attribute is a single
            <code>AccessibleNode</code> or an <code>AccessibleNodeList</code>.
          <dt>reciprocal</dt>
          <dd>Relationship attributes that is the inverse of this one..</dd>
          <dt>related ARIA attribute</dt>
          <dd>The corresponding ARIA attributes, if any</dd>
        </dl>
        <p>
          AccessibleNodes support the following accessibility relationship attributes:
        </p>
        <table>
          <caption>
            Relationship attribute table
          </caption>
          <thead>
            <tr>
              <th>attribute name</th>
              <th>type</th>
              <th>reciprocals</th>
              <th>related ARIA attributes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>activeDescendant</code></td>
              <td><code>AccessibleNode</code></td>
              <td><em>None</em></td>
              <td><code><nobr>aria-activedescendant</nobr></code></td>
            </tr>
            <tr>
              <td><code>children</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>parent</code></td>
              <td><code>aria-owns</code></td>
            </tr>
            <tr>
              <td><code>controlledBy</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>controllerFor</code></td>
              <td><em>None</em></td>
            </tr>
            <tr>
              <td><code>controllerFor</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>controlledBy</code></td>
              <td><code>aria-controls</code></td>
            </tr>
            <tr>
              <td><code>describedBy</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>descriptionFor</code></td>
              <td><code>aria-describedBy</code></td>
            </tr>
            <tr>
              <td><code>descriptionFor</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>describedBy</code></td>
              <td><em>None</em></td>
            </tr>
            <tr>
              <td><code>labeledBy</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>labelFor</code></td>
              <td><code>aria-labelledby</code></td>
            </tr>
            <tr>
              <td><code>labelFor</code></td>
              <td><code>AccessibleNodeList</code></td>
              <td><code>labeledBy</code></td>
              <td><em>None</em></td>
            </tr>
            <tr>
              <td><code>offsetParent</code></td>
              <td><code>AccessibleNode</code></td>
              <td><em>None</em></td>
              <td><em>None</em></td>
            </tr>
            <tr>
              <td><code>parent</code></td>
              <td><code>AccessibleNode</code></td>
              <td><code>children</code></td>
              <td><em>None</em></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h3>
          Position attributes
        </h3>
        <p>
          The position of an AccessibleNode is determined by the
          <code>offsetLeft</code>,
          <code>offsetTop</code>,
          <code>offsetWidth</code>, and <code>offsetHeight</code>
          attributes, which all give coordinates in CSS pixels
          relative to the
          <code>offsetParent</code>. A node's <code>offsetParent</code>
          will be its parent in the accessibility tree by default,
          but authors can override this in order to absolutely-position
          an element, or position it relative to any other element
          on the page.
        </p>
      </section>
      <section>
        <h3>
          Accessibility input events
        </h3>
        <p>
          All AccessibilityNodes are EventTargets, so authors
          can register event listeners on them. AccessibilityNodes
          receive special <dfn>accessibility input events</dfn>
          that represent explicit intents to control the user agent
          via an accessibility API
        </p>
        <p>
          Accessibility input events are needed for two reasons.
          First, because it's possible to create AccessibleNodes
          that don't correspond to a DOM node and authors need to
          be able to listen to events on these nodes. Second,
          because there are many types of specific user intents
          that can be communicated to the user agent via accessibility
          APIs that don't correspond to existing keyboard and mouse
          events - for example some assistive technology has
          keystrokes or gestures to increment a slider, or dismiss
          a pop-up.
        </p>
        <pre class="idl">
          interface AccessibleInputEvent : Event {
          };
          interface AccessibleSetValueEvent : AccessibleInputEvent {
            DOMString value;
          };
        </pre>
        <table>
          <caption>
            Accessibility event table
          </caption>
          <thead>
            <tr>
              <th>event name</th>
              <th>type</th>
              <th>valid roles</th>
              <th>fallback behavior</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>"accessibleclick"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>Fire <code>"click"</code> event on DOM node</td>
            </tr>
            <tr>
              <td><code>"accessiblefocus"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>Focus the associated DOM element</td>
            </tr>
            <tr>
              <td><code>"accessiblesetvalue"</code></td>
              <td><code>AccessibleSetValueEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>Change value of INPUT or TEXTAREA element</td>
            </tr>
            <tr>
              <td><code>"accessibleincrement"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>
                Change value of INPUT type="range",
                otherwise fire <code>"keypress"</code> with a
                RightArrow key code
              </td>
            </tr>
            <tr>
              <td><code>"accessibledecrement"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>
                Change value of INPUT type="range",
                otherwise fire <code>"keypress"</code> with a
                LeftArrow key code
              </td>
            </tr>
            <tr>
              <td><code>"accessibleselect"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"cell"</code>,
                <code>"option"</code>
              </td>
              <td>
                Change selectedIndex of SELECT
                otherwise fire <code>"click"</code> event
              </td>
            </tr>
            <tr>
              <td><code>"accessiblescrollintoview"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>scroll DOM node into view</td>
            </tr>
            <tr>
              <td><code>"accessibledismiss"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>fire <code>"keypress"</code> with a
                Escape key code</td>
            </tr>
          </tbody>
        </table>
        <p>
          Accessibility input events go through capture and bubble
          phases, just like DOM events. The only difference is that
          the capture and bubble phases happen entirely in the
          accessibility tree. If the event is not canceled
          (by calling <code>preventDefault()</code>) after completely
          going through the capture and bubble phases in the accessibility
          tree, the event executes its <dfn>fallback behavior</dfn>,
          as defined in the table above.
        </p>
        <p>
          When an event's fallback behavior involves firing a DOM
          event, the event's target will be the associated DOM node
          of the target AccessibleNode, or the associated DOM node
          of the nearest ancestor of the target AccessibleNode that
          has one. Fallback DOM events will go through capture and
          bubble phases just like any other DOM events.
        </p>
        <p>
          As an example, suppose an accessible click event is received
          on a button. Here's the sequence of what will occur:
          <ol>
            <li>Capturing event listeners are called, starting with the
              root of the accessibility tree, and continuing along the
              ancestor chain until reaching the target AccessibleNode in
              the accessibility tree.
            <li>If none of the capturing event listeners stop
              propagation, normal (non-capturing) event listeners on the
              target AccessibleNode are called, and if
              <code>stopPropagation()</code> is not called, the event
              bubbles up to all event listeners on ancestors of the
              target.
            <li>After capture and bubble phases in the accessibility tree,
              if <code>preventDefault()</code> was not called, the
              event's <dfn>fallback behavior</dfn> is triggered. In this
              case it fires a DOM <code>"click"</code> event on the
              targer AccessibleNode's associated DOM node, going through
              capture and bubble phases in the DOM tree.
          </ol>
        </p>
      </section>
    </section>
    <section>
      <h2>Implementation Phases</h2>
      <p>
        <em>This section is non-normative.</em>
      </p>
      <p>
        This spec is designed to be implemented in phases in order to
        accelerate the development process while providing ample
        opportunities for getting feedback from web authors and users
        while the spec is still under development.
      </p>
      <section>
        <h3>Introspection</h3>
        <pre class="idl">
          partial interface Node {
            readonly attribute AccessibleDOMNode? accessibleNode;
          };

          interface AccessibleNode {
            readonly attribute DOMString role;

            any getAttribute(DOMString attributeName);
          };

          interface AccessibleDOMNode : AccessibleNode {
            readonly attribute Node node;
          };
        </pre>
        <p>
          This phase contains all of the functionality necessary
          to examine the accessibility attributes of any DOM node.
        </p>
      </section>
      <section>
        <h3>Exploration</h3>
        <pre class="idl">
          partial interface AccessibleNode {
            any getRelation(DOMString relationName);
          };

          interface AccessibleNodeList {
            readonly attribute unsigned long length;
            getter AccessibleNode? getNode(unsigned long index);
          };
        </pre>
        <p>
          This phase adds the ability to expore the accessibility
          tree, including accessible nodes without associated DOM nodes,
          like nodes for generated CSS content. It also allows
          exploring other types of relationships like labelledBy
          and labelFor.
        </p>
      </section>
      <section>
        <h3>Modification</h3>
        <pre class="idl">
          interface AccessibleNode {
            void setAttribute(DOMString attributeName, any value);
          };
        </pre>
        <p>
          This phase adds the ability to modify accessibility attributes.
        </p>
      </section>
      <section>
        <h3>Rearranging</h3>
        <pre class="idl">
          [Constructor(DOMString role)]
          interface AccessibleNode {
            void setRelation(DOMString relationName, any relatives);
          };
        </pre>
        <p>
          This phase adds the ability to construct an AccessibleNode,
          rearrange AccessibleNodes within the accessibility tree,
          and set other relationship attributes.
        </p>
      </section>
      <section>
        <h3>Events and announcements</h3>
        <pre class="idl">
          [Constructor(DOMString role)]
          interface AccessibleNode : EventTarget {
            void focus();
            void announce(DOMString message);
          };
        </pre>
        <p>
          The final phase adds support for all of the accessible
          input events and the ability to focus or post an
          announcement on an AccessibleNode.
        </p>
      </section>
      <section>
        <h3>
          Future work
        </h3>
        <p>
          The following were considered as possible accessibility
          attributes but were deferred for a future version of the
          spec. Please file a bug if you have a compelling use case
          for one of these.
        </p>
        <ul>
          <li><code>checked</code>
          <li><code>current</code>
          <li><code>details</code>
          <li><code>errorMessage</code>
          <li><code>flowTo</code>
          <li><code>keyboardShortcuts</code>
          <li><code>liveAtomic</code>
          <li><code>liveBusy</code>
          <li><code>liveRelevant</code>
          <li><code>liveStatus</code>
          <li><code>modal</code>
          <li><code>multiline</code>
          <li><code>offscreen</code>
          <li><code>pressed</code>
          <li><code>roleDescription</code>
          <li><code>scrollable</code>
          <li><code>scrollX</code>
          <li><code>scrollXMin</code>
          <li><code>scrollXMax</code>
          <li><code>scrollY</code>
          <li><code>scrollYMin</code>
          <li><code>scrollYMax</code>
          <li><code>text</code>
        </uL>
        <p>
          The following were considered as possible accessibility
          input events but were deferred for a future version of the
          spec. Please file a bug if you have a compelling use case
          for one of these.
        </p>
        <ul>
          <li><code>"addtoselection"</code>
          <li><code>"collapse"</code>
          <li><code>"delete"</code>
          <li><code>"expand"</code>
          <li><code>"medianext"</code>
          <li><code>"mediapause"</code>
          <li><code>"mediaprevious"</code>
          <li><code>"mediastart"</code>
          <li><code>"mediastop"</code>
          <li><code>"removefromselection"</code>
          <li><code>"scroll"</code>
          <li><code>"zoom"</code>
        </ul>
      </section>
    </section>
    <section class='appendix'>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many thanks for valuable feedback, advice, and tools from:
        Robin Berjon, Marcos Caceres, Nan Wang, Ian Hickson, and Domenic Denicola.
      </p>
    </section>
  </body>
</html>
