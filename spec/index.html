<!DOCTYPE html>
<html>
  <head>
    <title>
      Accessibility Object Model
    </title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async
    class='remove'>
    </script>
    <script class='remove'>
    /*Make tidy happy*/
    var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "aom",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alice Boxhall"
              ,   url:        "http://google.com"
              ,   mailto:     "aboxhall@google.com"
              ,   company:    "Google"
              ,   companyURL: "http://google.com/"
              },
              {
                  name:       "James Craig"
              ,   url:        "http://apple.com"
              ,   mailto:     "jcraig@apple.com"
              ,   company:    "Apple"
              ,   companyURL: "http://apple.com/"
              },
              {
                  name:       "Dominic Mazzoni"
              ,   url:        "http://google.com"
              ,   mailto:     "dmazzoni@google.com"
              ,   company:    "Google"
              ,   companyURL: "http://google.com/"
              },
              {
                  name:       "Alexander Surkov"
              ,   url:        "http://mozilla.org/"
              ,   mailto:     "surkov.alexander@gmail.com"
              ,   company:    "Mozilla"
              ,   companyURL: "http://mozilla.org/"
              },
          ],
          // name of the WG
          //         wg:           "None",

          // URI of the public WG page
          //         wgURI:        "http://example.org/really-cool-wg",

          // name (without the @w3c.org) of the public mailing to which comments are due
          //          wgPublicList: "spec-writers-anonymous",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          //        wgPatentURI:  "",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
    <style>
      table{
        border:solid 2px #999;
        border-width:1px 0 0 1px;
        margin:0.1em 0 1em;
        padding:0;
        border-spacing:0;
        border-collapse:collapse;
      }
      th, td{
        border:solid 2px #999;
        border-width:0 1px 1px 0;
        padding:0.15em 0.3em 0.1em;
        /*min-width:20em;*/
        vertical-align:top;
        text-align:left;
      }
      th+th, td+td{
        width:auto;
      }
      th{
        background-color:#eee;
      }
      caption{
        text-align:left;
        color:#555;
        font-style:normal;
        margin:1em 0 0.1em;
        padding:0 0 0 0.3em;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification provides a way for authors to make web apps
        accessible using scripting, rather than the only option being
        declarative accessibility features of HTML markup. In the
        first phase, the author is able to programmatically
        modify the accessible representation of an existing DOM
        element. In future phases, the author is able to respond to
        additional input events from assistive technology,
        create new virtual accessible objects on the page that don't
        correspond to an HTML element at all, and explore the computed
        accessibility tree.
      </p>
    </section>
    <section id="introduction" class="informative">
      <h1>Introduction</h1>
      <section id="explainer">
        <h2>Explainer</h2>
        <p>
          <b>Note:</b> This spec is an <b>early draft</b> and doesn't
          contain all of the relevant background material,
          definitions, and motivation behind the design decisions.
        </p>
        <p>
          Please refer to the
          <a href="https://github.com/a11y-api/a11y-api/blob/master/explainer.md">
            Accessibility Object Model Explainer</a> for the background and
          motivation.
        </p>
        <p>If you have questions, comments, or other feedback, please
          <a href="https://github.com/a11y-api/a11y-api/issues">file an issue</a> on GitHub.
        </p>
      </section>
      <section id="scope">
        <h2>Document Scope</h2>
        <p>The Accessibility Object Model spec is narrowly focused on the goal of creating a scripting API for web accessibility. It's intended to complement existing web accessibility APIs such as [[!WAI-ARIA]], not replace them. In particular, this spec attempts to avoid proposing new roles, states, and properties an of accessible objects except where necessary.</p>
      </section>
      <section id="inclusion">
        <h2>Criteria for Inclusion</h2>
        <p>The first version of this specification is not intended to be complete. It is currently impossible to make some web features accessible, so the primary goal is to resolve immediate needs quickly for existing, inaccessible web interfaces. The specification editors are purposefully deferring many useful ideas in order to maintain a realistic timeline for highest priority features.</p>
        <p>
          We have defined <a href="http://a11y-api.github.io/a11y-api/spec/criteria.html">Inclusion/Exclusion Criteria</a>
          in order to clarify exactly what will be considered in-scope.
        </p>
      </section>
    </section>
    <section id="properties">
      <h2>
        Phase 1: Accessible Properties
      </h2>
      <section>
        <h3>
          Extensions to the <code>Node</code> interface
        </h3>
        <p>
          The author can request an <a>accessible node</a> from any [[!DOM]]
          <code>Node</code> that is rendered as part of a web page.
        </p>
        <pre class="idl">
          partial interface Node {
            readonly attribute AccessibleNode accessibleNode;
          };
        </pre>
        <p data-dfn-for="Node">
          The <dfn>accessibleNode</dfn> attribute returns the <a>accessible
          node</a> associated with this <code>DOM node</code>. It always returns
          a valid object if the browser supports the AOM.
        </p>
      </section>
      <section id="accessiblenode">
        <h3>
          <code>AccessibleNode</code> interface
        </h3>
        <pre class="idl">
        enum AutocompleteType { "none", "inline", "list", "both" };
        enum CheckedType { "false", "mixed", "true" };
        enum InvalidType { "false", "true", "grammar", "spelling" };
        enum LiveType { "off", "polite", "assertive" };
        enum LiveRelevantType { "additions", "additions text", "all", "removals", "text" };
        enum OrientationType { "horizontal", "vertical" };
        enum SortType { "none", "ascending", "descending", "other" };

        interface AccessibleNode {
          attribute DOMString role;

          // Accessible label and description.
          attribute DOMString? label;
          attribute DOMString? description;

          // Widget properties.
          attribute AutocompleteType? autocomplete;
          attribute boolean? hidden;
          attribute boolean? multiselectable;
          attribute OrientationType? orientation;
          attribute boolean? readonly;
          attribute boolean? required;
          attribute boolean? selected;
          attribute SortType? sort;

          // Widget states.
          attribute CheckedType checked;
          attribute boolean? expanded;
          attribute boolean? disabled;
          attribute InvalidType? invalid;
          attribute boolean hasPopUp;

          // Control values.
          attribute DOMString? value;
          attribute DOMString? placeholder;
          attribute double? rangeValue;
          attribute double? rangeMin;
          attribute double? rangeMax;
          attribute double? rangeStep;

          // Live regions.
          attribute boolean? liveAtomic;
          attribute boolean? liveBusy;
          attribute LiveType? liveStatus;
          attribute LiveRelevantType? liveRelevant;

          // Relationships.
          attribute AccessibleNode? activeDescendant;
          attribute iterable&lt;AccessibleNode&gt; controls;
          attribute iterable&lt;AccessibleNode&gt; describedBy;
          attribute AccessibleNode? details;
          attribute AccessibleNode? errorMessage;
          attribute AccessibleNode? flowTo;
          attribute iterable&lt;AccessibleNode&gt; labeledBy;

          // Collections.
          attribute unsigned long? colCount;
          attribute unsigned long? colIndex;
          attribute unsigned long? colSpan;
          attribute unsigned long? posInSet;
          attribute unsigned long? rowCount;
          attribute unsigned long? rowIndex;
          attribute unsigned long? rowSpan;
          attribute unsigned long? setSize;
          attribute unsigned long? level;
        };
        </pre>
        <p>
          All AccessibleNode properties, on setting, store the provided value.
          On getting, they return the user-provided value if present, and otherwise
          the value from the associated DOM Node's equivalent ARIA attribute, if any,
          and otherwise they return null.
        </p>
        <p>
          Values set on a DOM Node's AccessibleNode become the primary source of
          truth for the browser's implementation of native accessibility APIs for
          that accessibility property, overriding the equivalent ARIA
          attribute if valid.
        </p>
        <p>
          If a property of AccessibleNode is set to an invalid value, it is ignored
          and the calculation of that ARIA attribute falls back on the ARIA attribute,
          if present, and on the node's native semantics otherwise.
        </p>
      </section>
      <section id="mapping">
        <h3>
          Mapping to ARIA attributes
        </h3>
        <p>
          Nearly all accessibility properties on the AccessibleNode interface have an
          equivalent ARIA attribute. When they do, the mappings are very straightforward.
          This table shows the mappings and indicates the ones that have different semantics
          explained below.
        </p>

      <table>
        <caption>
          <dfn>Accessibility property table</dfn>
        </caption>
        <thead>
          <tr>
            <th>Attribute name</th>
            <th>Type</th>
            <th>Equivalent ARIA attribute</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>activeDescendant</code></td>
            <td><code>AccessibleNode</code></td>
            <td><code>aria-activedescendant</code></td>
          </tr>
          <tr>
            <td><code>autocomplete</code></td>
            <td><code>enum { "both", "inline", "list", "none" }?</code></td>
            <td><code><nobr>aria-autocomplete</nobr></code></td>
          </tr>
          <tr>
            <td><code>checked</code></td>
            <td><code>enum { "false", "mixed", "true" }</code></td>
            <td><code><nobr>aria-checked</nobr></code></td>
          </tr>
          <tr>
            <td><code>colCount</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-colcount</nobr></code></td>
          </tr>
          <tr>
            <td><code>colIndex</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-colindex</nobr></code></td>
          </tr>
          <tr>
            <td><code>colSpan</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-colSpan</nobr></code></td>
          </tr>
          <tr>
            <td><code>controls</code></td>
            <td><code>iterable&lt;AccessibleNode&gt;</code></td>
            <td><code>aria-controls</code></td>
          </tr>
          <tr>
            <td><code>description</code></td>
            <td><code>DOMString</code></td>
            <td>*</td>
          </tr>
          <tr>
            <td><code>details</code></td>
            <td><code>AccessibleNode</code></td>
            <td><code>aria-details</code></td>
          </tr>
          <tr>
            <td><code>describedBy</code></td>
            <td><code>iterable&lt;AccessibleNode&gt;</code></td>
            <td><code>aria-describedby</code></td>
          </tr>
          <tr>
            <td><code>disabled</code></td>
            <td><code>boolean?</code></td>
            <td><code><nobr>aria-disabled</nobr></code></td>
          </tr>
          <tr>
            <td><code>errorMessage</code></td>
            <td><code>AccessibleNode</code></td>
            <td><code>aria-errormessage</code></td>
          </tr>
          <tr>
            <td><code>expanded</code></td>
            <td><code>boolean?</code></td>
            <td><code><nobr>aria-expanded</nobr></code></td>
          </tr>
          <tr>
            <td><code>hasPopUp</code></td>
            <td><code>boolean</code></td>
            <td><code><nobr>aria-haspopup</nobr></code></td>
          </tr>
          <tr>
            <td><code>hidden</code></td>
            <td><code>boolean</code></td>
            <td><code><nobr>aria-hidden</nobr></code></td>
          </tr>
          <tr>
            <td><code>invalid</code></td>
            <td><code>enum { "grammar", "false", "spelling", "true" }?</code></td>
            <td><code><nobr>aria-invalid</nobr></code></td>
          </tr>
          <tr>
            <td><code>labeledBy</code></td>
            <td><code>iterable&lt;AccessibleNode&gt;</code></td>
            <td><code>aria-labelledby</code></td>
          </tr>
          <tr>
            <td><code>label</code></td>
            <td><code>DOMString</code></td>
            <td>*</td>
          </tr>
          <tr>
            <td><code>level</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-level</nobr></code></td>
          </tr>
          <tr>
            <td><code>multiselectable</code></td>
            <td><code>boolean</code></td>
            <td><code><nobr>aria-multiselectable</nobr></code></td>
          </tr>
          <tr>
            <td><code>orientation</code></td>
            <td><code>enum { "horizontal", "vertical" }?</code></td>
            <td><code><nobr>aria-orientation</nobr></code></td>
          </tr>
          <tr>
            <td><code>placeholder</code></td>
            <td><code>DOMString?</code></td>
            <td><code><nobr>aria-placeholder</nobr></code></td>
          </tr>
          <tr>
            <td><code>posInSet</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-posinset</nobr></code></td>
          </tr>
          <tr>
            <td><code>rangeValue</code></td>
            <td><code>double?</code></td>
            <td><code><nobr>aria-valuenow</nobr></code></td>
          </tr>
          <tr>
            <td><code>rangeMin</code></td>
            <td><code>double?</code></td>
            <td><code><nobr>aria-valuemin</nobr></code></td>
          </tr>
          <tr>
            <td><code>rangeMax</code></td>
            <td><code>double?</code></td>
            <td><code><nobr>aria-valuemax</nobr></code></td>
          </tr>
          <tr>
            <td><code>readonly</code></td>
            <td><code>boolean?</code></td>
            <td><code><nobr>aria-readonly</nobr></code></td>
          </tr>
          <tr>
            <td><code>required</code></td>
            <td><code>boolean?</code></td>
            <td><code><nobr>aria-required</nobr></code></td>
          </tr>
          <tr>
            <td><code>rowCount</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-rowcount</nobr></code></td>
          </tr>
          <tr>
            <td><code>rowIndex</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-rowindex</nobr></code></td>
          </tr>
          <tr>
            <td><code>rowSpan</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-rowspan</nobr></code></td>
          </tr>
          <tr>
            <td><code>selected</code></td>
            <td><code>boolean?</code></td>
            <td><code><nobr>aria-selected</nobr></code></td>
          </tr>
          <tr>
            <td><code>setSize</code></td>
            <td><code>unsigned long?</code></td>
            <td><code><nobr>aria-setsize</nobr></code></td>
          </tr>
          <tr>
            <td><code>sort</code></td>
            <td><code>enum { "ascending", "descending", "none", "other" }?</code></td>
            <td><code><nobr>aria-sort</nobr></code></td>
          </tr>
          <tr>
            <td><code>value</code></td>
            <td><code>DOMString?</code></td>
            <td>*</td>
          </tr>
        </tbody>
      </table>

        <p>
          In web accessibility, every node in the accessibility
          tree has an <dfn>accessible name</dfn> and
          <dfn>accessible description</dfn>, which are computed
          using the algorithm described in [[!ACCNAME-AAM-1.1]].
          The name is primary, the description is secondary.
        </p>
        <p>
          There are many possible sources of the accessible name
          of an element from its declarative markup. As an example,
          an HTML INPUT element may get its accessible name from
          an associated LABEL element, from the <code>title</code>
          attribute, from the <code>aria-label</code>
          attribute, from the <code>aria-labelledby</code>
          attribute, or more. The [[!ACCNAME-AAM-1.1]] algorithm
          specifies exactly how these combine to form the final
          accessible name.
        </p>
        <p>
          When using the AccessibleNode interface, it's much simpler.
          The <code>label</code> property determines the accessible
          name and the <code>description</code> property determines
          the accessible description. In addition, the
          <code>labelledBy</code> attribute contains references to
          other accessible nodes that provided the label for a node,
          and the <code>describedBy</code> attribute contains
          references to other accessible nodes that provided
          the description, but those relation attributes are
          informational only.
        </p>
        <p>
          In particular, setting an AccessibleNode's
          <code>labelledBy</code> or <code>describedBy</code>
          attributes will have <em>no effect</em> on its
          accessible name or description. The only purpose of
          setting them is to communicate the relationship between
          nodes to assistive technology. Set the
          <code>label</code> and <code>description</code>
          attributes directly if you want those to change.
        </p>
        <p>
          Similarly, the <code>value</code> property represents the
          text value of a control, such as a text field or slider.
          ARIA notably only provides a way to override the value for
          range widgets using <code>aria-valuetext</code>, but the
          <code>value</code> property of an AccessibleNode can be used
          to override the value of any control that takes a value.
        </p>

        <p>
          The following ARIA attributes have no direct mapping:
        </p>

        <ul>
          <li><code>aria-current</code> (TODO)
          <li><code>aria-dropeffect</code> - deliberate since deprecated in ARIA 1.1
          <li><code>aria-grabbed</code> - deliberate since deprecated in ARIA 1.1
          <li><code>aria-keyshortcuts</code> (TODO)
          <li><code>aria-label</code> - <code>label</code> has slightly different semantics
          <li><code>aria-modal</code> (TODO)
          <li><code>aria-multiline</code> (TODO)
          <li><code>aria-owns</code> - tricky to reconcile with more explicit tree reordering later
          <li><code>aria-pressed</code> (TODO)
          <li><code>aria-roledescription</code> (TODO)
          <li><code>aria-valuetext</code> - <code>value</code> has slightly different semantics
        </ul>
      </section>
    </section>
    <section id="actions">
      <h2>
        Phase 2: Accessible Actions
      </h2>
        <p>
          In this phase, we extent AccessibleNode so that it's also an
          EventTarget.  AccessibleNodes receive
          special <b>accessibility input events</b> or <b>accessible
          actions</b> that represent explicit intents to control the
          user agent via an accessibility API
        </p>
        <pre class="idl">
          interface AccessibleNode : EventTarget {
            ...
          };
        </pre>
        <p>
          Accessibility input events are needed for two reasons.
          First, because it's possible to create AccessibleNodes
          that don't correspond to a DOM node and authors need to
          be able to listen to events on these nodes. Second,
          because there are many types of specific user intents
          that can be communicated to the user agent via accessibility
          APIs that don't correspond to existing keyboard and mouse
          events - for example some assistive technology has
          keystrokes or gestures to increment a slider, or dismiss
          a pop-up.
        </p>
        <pre class="idl">
          interface AccessibleSetValueEvent : Event {
            attribute DOMString value;
          };
        </pre>
        <table>
          <caption>
            Accessibility event table
          </caption>
          <thead>
            <tr>
              <th>event name</th>
              <th>type</th>
              <th>valid roles</th>
              <th>fallback behavior</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>"accessibleclick"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>Fire <code>"click"</code> event on DOM node</td>
            </tr>
            <tr>
              <td><code>"accessiblefocus"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>Focus the associated DOM element</td>
            </tr>
            <tr>
              <td><code>"accessiblesetvalue"</code></td>
              <td><code>AccessibleSetValueEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>Change value of INPUT or TEXTAREA element</td>
            </tr>
            <tr>
              <td><code>"accessibleincrement"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>
                Change value of INPUT type="range",
                otherwise fire <code>"keypress"</code> with a
                RightArrow key code
              </td>
            </tr>
            <tr>
              <td><code>"accessibledecrement"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>
                Change value of INPUT type="range",
                otherwise fire <code>"keypress"</code> with a
                LeftArrow key code
              </td>
            </tr>
            <tr>
              <td><code>"accessibleselect"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"cell"</code>,
                <code>"option"</code>
              </td>
              <td>
                Change selectedIndex of SELECT
                otherwise fire <code>"click"</code> event
              </td>
            </tr>
            <tr>
              <td><code>"accessiblescrollintoview"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>scroll DOM node into view</td>
            </tr>
            <tr>
              <td><code>"accessibledismiss"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>fire <code>"keypress"</code> with a
                Escape key code</td>
            </tr>
          </tbody>
        </table>
        <p>
          Accessibility input events go through capture and bubble
          phases, just like DOM events. The only difference is that
          the capture and bubble phases happen entirely in the
          accessibility tree. If the event is not canceled
          (by calling <code>preventDefault()</code>) after completely
          going through the capture and bubble phases in the accessibility
          tree, the event executes its <dfn>fallback behavior</dfn>,
          as defined in the <a>accessibility attribute table</a>.
        </p>
        <p>
          When an event's fallback behavior involves firing a DOM
          event, the event's target will be the associated DOM node
          of the target AccessibleNode, or the associated DOM node
          of the nearest ancestor of the target AccessibleNode that
          has one. Fallback DOM events will go through capture and
          bubble phases just like any other DOM events.
        </p>
        <p>
          As an example, suppose an accessible click event is received
          on a button. Here's the sequence of what will occur:
          <ol>
            <li>Capturing event listeners are called, starting with the
              root of the accessibility tree, and continuing along the
              ancestor chain until reaching the target AccessibleNode in
              the accessibility tree.
            <li>If none of the capturing event listeners stop
              propagation, normal (non-capturing) event listeners on the
              target AccessibleNode are called, and if
              <code>stopPropagation()</code> is not called, the event
              bubbles up to all event listeners on ancestors of the
              target.
            <li>After capture and bubble phases in the accessibility tree,
              if <code>preventDefault()</code> was not called, the
              event's <a>fallback behavior</a> is triggered. In this
              case it fires a DOM <code>"click"</code> event on the
              targer AccessibleNode's associated DOM node, going through
              capture and bubble phases in the DOM tree.
          </ol>
        </p>

        <p>
          The following were considered as possible accessibility
          input events but were deferred for a future version of the
          spec. Please file a bug if you have a compelling use case
          for one of these.
        </p>
        <ul>
          <li><code>"addtoselection"</code>
          <li><code>"collapse"</code>
          <li><code>"delete"</code>
          <li><code>"expand"</code>
          <li><code>"medianext"</code>
          <li><code>"mediapause"</code>
          <li><code>"mediaprevious"</code>
          <li><code>"mediastart"</code>
          <li><code>"mediastop"</code>
          <li><code>"removefromselection"</code>
          <li><code>"scroll"</code>
          <li><code>"zoom"</code>
        </ul>
      <section>
        <h3>Privacy concerns</h3>
        <p>
          This phase raises some potential privacy concerns. If a web app
          receives an accessibility input event, it now knows for a fact
          that assistive technology or some other client of a native
          accessibility API is running. There is potential that this could be
          used to track or discriminate against some users.
        </p>
        <p>
          To address these concerns, a web site should not be able to
          receive these events until the user has explicitly opted in to
          allow those events to be received by that web site. The exact
          protocol is TBD.
        </p>
      </section>
    </section>
    <section class="virtual">
      <h2>
        Phase 3: Virtual Accessibility Nodes
      </h2>
      <p>
        Virtual Accessibility Nodes will allow authors to expose
        "virtual" accessibility nodes, which are not associated directly
        with any particular DOM node, to assistive technology.
      </p>
      <p>
        This mechanism is often present in native accessibility APIs,
        in order to allow authors more granular control over the
        accessibility of custom-drawn APIs.
      </p>
      <p>
        On the web, this would allow creating an accessible solution
        to canvas-based UI which does not rely on fallback or
        visually-hidden DOM content.
      </p>
      <p>
        The API for Virtual Accessibility Nodes will be specified at a later date.
      </p>
    </section>
    <section id="computedtree">
      <h2>
        Phase 4: Computed Accessibility Tree
      </h2>
      <p>
        The Computed Accessibility Tree API will allow authors to
        access the full computed accessibility tree - all computed
        properties for the accessibility node associated with each
        DOM node, plus the ability to walk the computed tree
        structure including virtual nodes.
      </p>
      <p>
        This will make it possible to:
      </p>
      <ul>
        <li>write any programmatic test which asserts anything about the semantic properties of an element or a page.
        <li>build a reliable browser-based assistive technology - for example, a browser extension which uses the accessibility tree to implement a screen reader, screen magnifier, or other assistive functionality; or an in-page tool.
        <li>detect whether an accessibility property has been successfully applied (via ARIA or otherwise) to an element - for example, to detect whether a browser has implemented a particular version of ARIA.
        <li>do any kind of console-based debugging/checking of accessibility tree issues.
          react to accessibility tree state, for example, detecting the exposed role of an element and modifying the accessible help text to suit.
      </ul>
      <p>
        One implication of implementing this phase is that all browsers must agree on
        exposing the *same* accessibility tree for the same given webpage, otherwise
        differences will invariably lead to authored pages that work in some browsers
        but not others. Care must be taken to define this phase in such a way that
        maintains a high degree of compatibility between browsers, without exposing any
        internal details and nuances.
      </p>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many thanks for valuable feedback, advice, and tools from:
        Alex Russell, Bogdan Brinza, Chris Fleizach, Cynthia Shelley, David Bolter, Domenic Denicola, Ian Hickson, Joanmarie Diggs, Marcos Caceres, Nan Wang, Robin Berjon, and Tess O'Connor.
      </p>
      <p>
        Bogdan Brinza and Cynthia Shelley of Microsoft contributed to the first draft of this spec but are no longer actively participating.
      </p>
    </section>
  </body>
</html>
