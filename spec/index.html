<!DOCTYPE html>
<html>
  <head>
    <title>
      Accessibility Object Model
    </title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async
    class='remove'>
    </script>
    <script class='remove'>
    /*Make tidy happy*/
    var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "aom",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alice Boxhall"
              ,   url:        "http://google.com"
              ,   mailto:     "aboxhall@google.com"
              ,   company:    "Google"
              ,   companyURL: "http://google.com/"
              },
              {
                  name:       "Bogdan Brinza"
              ,   url:        "http://microsoft.com"
              ,   mailto:     "bbrinza@microsoft.com"
              ,   company:    "Microsoft"
              ,   companyURL: "http://microsoft.com/"
              },
              {
                  name:       "James Craig"
              ,   url:        "http://apple.com"
              ,   mailto:     "jcraig@apple.com"
              ,   company:    "Apple"
              ,   companyURL: "http://apple.com/"
              },
              {
                  name:       "Dominic Mazzoni"
              ,   url:        "http://google.com"
              ,   mailto:     "dmazzoni@google.com"
              ,   company:    "Google"
              ,   companyURL: "http://google.com/"
              },
              {
                  name:       "Cynthia Shelley"
              ,   url:        "http://microsoft.com"
              ,   mailto:     "cyns@microsoft.com"
              ,   company:    "Microsoft"
              ,   companyURL: "http://microsoft.com/"
              },
              {
                  name:       "Alexander Surkov"
              ,   url:        "http://mozilla.org/"
              ,   mailto:     "surkov.alexander@gmail.com"
              ,   company:    "Mozilla"
              ,   companyURL: "http://mozilla.org/"
              },
          ],
          // name of the WG
          //         wg:           "None",

          // URI of the public WG page
          //         wgURI:        "http://example.org/really-cool-wg",

          // name (without the @w3c.org) of the public mailing to which comments are due
          //          wgPublicList: "spec-writers-anonymous",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          //        wgPatentURI:  "",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
    <style>
      table{
        border:solid 2px #999;
        border-width:1px 0 0 1px;
        margin:0.1em 0 1em;
        padding:0;
        border-spacing:0;
        border-collapse:collapse;
      }
      th, td{
        border:solid 2px #999;
        border-width:0 1px 1px 0;
        padding:0.15em 0.3em 0.1em;
        /*min-width:20em;*/
        vertical-align:top;
        text-align:left;
      }
      th+th, td+td{
        width:auto;
      }
      th{
        background-color:#eee;
      }
      caption{
        text-align:left;
        color:#555;
        font-style:normal;
        margin:1em 0 0.1em;
        padding:0 0 0 0.3em;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        The web platform has a long history of features for developers
        to use to make their web content more accessible to users with
        disabilities, from the alt attribute on images to all of
        WAI-ARIA. A key component of these solutions is that user
        agents provide an alternate way to interact with a web app
        using native accessibility APIs specific to each
        platform. These APIs are used by a variety of assistive
        technologies, including but not limited to screen readers and
        magnifiers for visually impaired users, and switch access
        software and voice control software for motor-impaired
        users. Accessibility APIs are also often used for automation
        and automated testing.
      </p>
      <p>
        Increasingly, apps that take full advantage of some new web
        platform features are finding it difficult or impossible to
        make their apps accessible. In particular, one of the biggest
        challenges happens when a web app uses scripting, and not
        declarative markup, for a significant portion of its user
        interface - for example building a portion of the interface
        using the HTML canvas element (both 2D and WebGL). Authors are
        forced to create fake invisible DOM elements that represent
        accessible objects on the screen, a hack that's cumbersome,
        limited, and ultimately bad for the platform.
      </p>
      <p>
        The solution is to make it possible for an author to make an
        app accessible using scripting, where desirable, rather than
        the only option being accessible features of HTML markup. In a
        simple use case, the author is able to set an
        accessibility property of an HTML element via JavaScript
        without affecting that element's HTML attributes. In a more
        complicated use case, the author is able to create new
        virtual accessible objects on the page that don't correspond
        to an HTML element at all, such as controls in a Canvas-based
        app.
      </p>
      <p>
        This spec is narrowly focused on the goal of creating a
        scripting API for web accessibility. It's intended to
        complement existing web accessibility APIs such as
        [[!WAI-ARIA]], not replace them. In particular, this spec
        attempts to avoid proposing new roles, states, and properties
        an accessible object can have except where necessary;
        otherwise it just defines a mechanism by which an accessible
        object with those same roles, states and properties can be
        defined without necessarily being tied to the HTML DOM.
      </p>
    </section>
    <section>
      <h2>
        Introduction
      </h2>
      <p>
        <em>This section is non-normative.</em>
      </p>
      <p>
        This API is called the Accessibility Object Model because it's based
        around the idea that all modern operating systems, including
        both desktop and mobile operating systems, have native APIs that
        allow an application to be explored and controlled via a high-level
        semantic interface for the purposes of accessibility or automation.
        A key component of these interfaces across all platforms is that
        they represent each application's user interface as a tree of
        accessible objects.
      </p>
      <p>
        The canonical example of a client of accessibility APIs is a
        <i>screen reader</i> used by blind users to access a computer or
        mobile device using synthesized speech or braille. Other examples
        include magnifiers, voice control software, and switch access software,
        plus testing and automation tools. All of these accessibility
        clients can do three things:
        <ol>
          <li>Explore the tree of accessible objects representing the
            current state of the application's user interface,
          <li>Listen for notifications from the application when the
            user interface has changed, and
          <li>Control the interface by commanding it to set focus,
            activate a control, enter text, and more.
        </ol>
      </p>
      <p>
        Web browsers have long had support for accessibility APIs,
        allowing all sorts of assistive technology and testing tools
        access to everything in a web page. The HTML standard defined
        attributes like <code>alt</code> that allow the HTML author to provide
        an accessible text alternative for an image.
      </p>
      <p>
        As the web became used more for applications and not just documents,
        the [[!WAI-ARIA]] standard was created to allow web authors to
        fill in missing semantics in the accessibility tree.
      </p>
      <p>
        A fundamental assumption of [[!WAI-ARIA]], though, is that there's
        essentially a one-to-one correspondence between a DOM element
        and an accessible node. While there are ways to hide
        presentational DOM elements from the accessibility tree, there are
        no ways to create accessible nodes that don't correspond to
        DOM elements. This is one of the gaps this spec aims to address.
      </p>
      <section class="informative">
        <h3>
          Understanding the terms
        </h3>
        <p>
          A web page or web app is made up of a tree of accessible nodes.
          Typically each DOM node gets a corresponding accessible node,
          but this API allows the author to create additional accessible
          elements and create relationships between accessible nodes
          that aren't present in the DOM.
          Each <a>accessible node</a> is described by
          accessible properties like <a>role</a>, <a>name</a>, <a>relations</a>
          etc.
        </p>
        <figure>
          <img src="images/props.png" alt="accessible properties diagram">
          <figcaption>
            Accessible properties.
          </figcaption>
        </figure>
        <p>
          <a>accessible nodes</a> can be related to each other
          in a number of ways.
        </p>
        <figure>
          <img src="images/rels.png" alt="accessible relations diagram">
          <figcaption>
            Relations. A color of arrows connecting accessible node
            represent own relation type.
          </figcaption>
        </figure>
        <p>
          All <a>accessible nodes</a> are organized into an
          accessibility tree, with strict parent-child relationships.
        </p>
        <figure>
          <img src="images/tree.png" alt="accessibility tree">
          <figcaption>
            Accessibility tree.
          </figcaption>
        </figure>
        <p>
          The browser exposes semantics of the content to the accessibility
          client (like assistive technology or automation software) via
          platform APIs like ATK, IAccessible2, UIA, or NSAccessibility.
          The client communicates back to the content by the browser
          via platform APIs.
        </p>
        <figure>
          <img src="images/overview.png" alt="overview diagram">
          <figcaption>
            Overview of the communication between the content and the
            <a>assistive technology</a>.
          </figcaption>
        </figure>
      </section>
      <section>
        <h3>
          The Accessibility Tree and Accessible Nodes
        </h3>
        <p>
          An <dfn>Accessibility Tree</dfn> is a semantic representation of an
          application's user interface enabling it to be observed and
          controlled by other client software programs, like assistive
          technology and automation software, via a platform-native
          <dfn>Accessibility API</dfn>. User agents typically provide
          support for one or more native accessibility APIs.
        </p>
        <p>
          The Accessibility Tree is made up of <dfn>Accessible Nodes</dfn>.
          Accessible Nodes have a <em>role</em> and several <a href="#attributes">
            Accessibility Attributes</a> that describe the node's current
          state, and other properties.
        </p>
        <p>
          In many cases, the Accessibility Tree exposed by a user agent
          corresponds closely to a web page's DOM tree, with one
          Accessible Node for every DOM Node. However, sometimes the trees
          need to differ - for example, several DOM elements may create a
          media player seek control, but in the Accessibility Tree that
          whole collection might be represented by a single Accessible Node
          with a role of "slider" and other attributes indicating its
          min, max, and current value.
        </p>
        <p>
          Authors can modify the way a DOM node is converted into the
          accessibility tree using [[!WAI-ARIA]] attributes. However, this
          approach is sometimes limited, so this spec provides the author
          with a richer programmatic interface to complement ARIA.
        </p>
      </section>
    </section>

    <section>
      <h2>
        Tutorial
      </h2>
      <p>
        <em>This section is non-normative.</em>
      </p>
      <section>
        <h3>
          Getting an AccessibleNode from a DOM Node
        </h3>
        <p>
          Initially, querying a property on an AccessibleNode backed by
          a node will return the computed value of that property.
          The following example shows a snippet of HTML for a
          heading along with the code to obtain the accessible node for it.
        </p>
        <pre class="example highlight">
          &lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
          &lt;script&gt;
            var contents = document.getElementById("contents");
            var axContents = contents.accessibleNode;
          &lt;/script&gt;</pre>
        </div>
        <p>
          Accessing the properties of the resulting object returns
          computed accessibility attributes of the DOM element, such as
          its role, level, and label:
        </p>
        <pre class="example highlight">
          axContents.role;   // returns "heading"
          axContents.level;  // returns 2
          axContents.label;  // returns "Contents"
        </pre>
      </section>
      <section>
        <h3>
          Modifying accessibility attributes
        </h3>
        <p>
          Most properties on an AccessibleNode can be modified. If you're
          familiar with [[!WAI-ARIA]] attributes, you'll recognize most of
          the properties and their legal values. Let's take the example
          above and change the role and label.
        </p>
        <pre class="example highlight">
          axContents.role = "region";
          axContents.label = "Table of contents";
        </pre>
        <p>
          Changing a property immediately affects the accessibility
          tree and the browser notifies any accessibility clients about
          the change. On an AccessibleNode, instead of several attributes
          that affect the computed name, a single property,
          <code>label</code>, determines its accessible name and it
          overrides any accessible text from the DOM.
        </p>
        <p>
          Setting the value of a property to <code>undefined</code>
          will have the effect of reverting any user-modified value
          and the property will have its computed value instead:
        </p>
        <pre class="example highlight">
          axContents.role = "region";
          axContents.role;  // Returns "region"

          axContents.role = undefined;
          axContents.role;  // Returns "heading"
        </pre>
        <p>
          Setting the value of a property to an illegal value will
          have the same effect as setting it to <code>undefined</code>,
          it will revert any user-modified value. This is useful as
          a form of feature detection.
        </p>
        <pre class="example highlight">
          axContents.role = "butler";
          axContents.role;  // Returns "heading", because "butler" is not a valid role.
        </pre>
        <h3>
          Optional properties
        </h3>
        <p>
          Some properties of AccessibleNode are optional, they are allowed to be
          null. For example, <code>rangeValue</code> only applies to elements
          with certain roles (like "slider" and "progressbar"), while
          <code>liveRelevant</code> only applies to elements thta are live
          regions. Other properties of AccessibleNode apply to all elements
          and are never null, for example <code>focusable</code> must always be
          true or false.
        </p>
      </section>
      <section>
        <h3>
          Relationship properties
        </h3>
        <p>
          Some properties express relationships between one AccessibleNode
          and one or more others, for example, <code>activeDescendant</code>
          and <code>labelledBy</code>. The semantics of these relationships
          are identical to their corresponding ARIA attributes. In ARIA, a
          relationship can only be expressed with an IDREF, i.e. by passing
          the ID of another element in the Document. With the
          AccessibleNode interface, it isn't necessary for the target
          element to have an ID. Furthermore, it isn't necessary for
          the the target element to be in the same Document, as long as
          it is form the same origin. This means it's possible to reference
          an element in an iframe from the same site, or an element inside
          shadow DOM. In the example below, a listbox sets its activeDescendant
          without putting an ID on any of the options.
        </p>
        <pre class="example highlight">
          &lt;div role="listbox"&gt;
            &lt;div role="option"&gt;Kirk&lt;/div&gt;
            &lt;div class="selected" role="option"&gt;Picard&lt;/div&gt;
          &lt;/div&gt;
          &lt;script&gt;
            var listbox = document.querySelector("[role='listbox']");
            var axListbox = listbox.accessibleNode;
            var selectedOption = listbox.querySelector(".selected");
            axListbox.activeDescendant = selectedOption.accessibleNode;
          &lt;/script&gt;</pre>
        </div>
      </section>
      <section>
        <h3>
          Exploring the accessibility tree
        </h3>
        <p>
          From any AccessibleNode, you can explore the rest of the
          accessibility tree in much the same way you explore the
          DOM tree, with properties ilke <code>firstChild</code>,
          <code>nextSibling</code>, and <code>parent</code>, as in
          this example.
        </p>
        <pre>
          &lt;ol id="list1"&gt;
            &lt;li&gt;The Original Series&lt;/li&gt;
            &lt;li&gt;The Next Generation&lt;/li&gt;
            &lt;li&gt;Deep Space Nine&lt;/li&gt;
            &lt;li&gt;Voyager&lt;/li&gt;
            &lt;li&gt;Enterprise&lt;/li&gt;
          &lt;/ol&gt;
          &lt;script&gt;
            var axList = document.getElementById("list1").accessibleElement;
            var axItem1 = axList.firstChild;
            var axItem2 = axItem1.nextSibling;
          &lt;/script&gt;</pre>
        </pre>
      </section>
      <section>
        <h3>
          Rearranging the accessibility tree
        </h3>
        <p>
          The Accessibility Object Model lets you arbitrarily rearrange
          nodes in the accessibility tree without affecting the DOM tree.
          For example, you can remove the first list item from the example
          above and put it at the end of the list instead:
        </p>
        <pre>
          axList.removeChild(axItem1);
          axList.appendChild(axItem1);
        </pre>
      </section>
      <section>
        <h3>
          Creating new "virtual" accessible nodes
        </h3>
        <p>
          A virtual AccessibleNode can be created that does not correspond to
          a DOM node. This is intended to be used to represent an object on the screen
          that's drawn using some other mechanism, such as an HTML Canvas.
          The AccessibleNode constructor takes a single argument that
          initializes the new object's role.
        </p>
        <pre class="highlight example">
          var axVirtualButton = new AccessibleNode("button");
          axVirtualButton.label = "Enable Audio Descriptions";
          axVirtualButton.offsetWidth = 224;
          axVirtualButton.offsetHeight = 72;
        </pre>
        <p>
          A virtual AccessibleNode isn't part of the document's
          accessibility tree until it's added as the child of another element,
          using one of the methods used to add or remove children:
        </p>
        <pre class="idl">
          void appendChild(AccessibleNode child);
          void insertBefore(AccessibleNode child, AccessibleNode before);
          void insertAfter(AccessibleNode child, AccessibleNode after);
          void removeChild(AccessibleNode child);
        </pre>
        <p>
          For example, this code would add the virtual button we created
          above as a child of the HTML body element's accessible node:
        </p>
        <pre class="highlight example">
          document.body.accessibleNode.appendChild(axVirtualButton);
        </pre>
        <p>
          The <code>appendChild</code>, <code>insertBefore</code>,
          <code>insertAfter</code>, and <code>removeChild</code>
          methods can be used to rearrange any elements in the
          accessibility tree for a document, including those that are
          backed by DOM Nodes. If the elements in the HTML DOM are not
          in the proper order for accessibility, these methods can be
          used to rearrange the accessibility tree so that it's
          correct semantically.
        </p>
        <p>
          If the argument to <code>appendChild</code> or <code>insertChild</code>
          was already part of the accessibility tree, it's automatically
          reparented. It's not necessary to remove it first. Because of this,
          it's not possible to accidentally create a cycle - if you add B as
          a child of A, and then try to add A as a child of B, that second
          step would have the effect of detaching A from its parent and the
          end result would be that A is a child of B, but both are detached
          from the document's accessibility tree.
        </p>
        <p>
          The only case where it's illegal to add an AccessibleNode as the
          child of another is if it's backed by a DOM element that comes from
          a different Document. That will raise an exception. The
          accessibility tree can only be rearranged within one Document.
        </p>
      </section>
      <section>
        <h3>
          Accessibility input events
        </h3>
        <p>
          AccessibleNodes are EventTargets and you can register event
          listeners for special accessibility input events that come
          from assistive technology. This is critical when building a
          virtual accessible node in order to make it interactive at
          all, but it can also be helpful for DOM-backed accessible
          nodes because there are some accessible input events that
          can be generated by assistive technology and have a clear
          semantic intent, like <em>increment</em> or
          <em>dismiss</em>, and can't be detected by other means.
        </p>
        <p>
          This example adds a virtual button to the pgae and registers
          a click listener on it.
        </p>
        <pre class="highlight example">
          var axVirtualButton = new AccessibleNode("button");
          axVirtualButton.label = "Enable Audio Descriptions";
          axVirtualButton.offsetWidth = 224;
          axVirtualButton.offsetHeight = 72;
          axVirtualButton.addEventListener("accessibleclick", function(event) {
            alert("clicked!");
          }, false);
          document.body.accessibleNode.appendChild(axVirtualButton);
        </pre>
        <p>
          Virtual accessible nodes can be focusable, but they'll never be
          part of the tab order. It's up to the author to track focus
          in virtual accessible nodes.
        </p>
      </section>
    </section>

    <section>
      <h2>
        Interfaces
      </h2>
      <section>
        <h3>
          Extensions to the <code>Node</code> interface
        </h3>
        <p>
          The author can request an <a>accessible node</a> from any [[!DOM]]
          <code>Node</code> that is rendered as part of a web page.
        </p>
        <pre class="idl">
          partial interface Node {
          readonly attribute AccessibleDOMNode? accessibleNode;
          };
        </pre>
        <p>
          The <code>accessibleNode</code> attribute returns the <a>accessible
          node</a> associated with this <code>DOM node</code>, or
          <code>null</code> if this DOM node is not currently rendered as
          part of a web page.
        </p>
      </section>
      <section>
        <h3>
          <code>AccessibleNode</code> and <code>AccessibleDOMNode</code> interfaces
        </h3>
        <p>
          An AccessibleNode is an interface that represents one node
          in the user agent's accessibility tree. A subclass,
          AccessibleDOMNode, can be retrieved directly from a DOM
          Node, or a new AccessibleNode can be constructed and
          inserted into the accessibility tree.
        </p>
        <pre class="idl">
          [Constructor(DOMString role)]
          interface AccessibleNode : EventTarget {
          attribute DOMString role;

          void setAttribute(DOMString attributeName, any value);
          any getAttribute(DOMString attributeName);

          readonly attribute AccessibleNode parent;
          readonly attribute AccessibleNode firstChild;
          readonly attribute AccessibleNode lastChild;
          readonly attribute AccessibleNode nextSibling;
          readonly attribute AccessibleNode previousSibling;

          void appendChild(AccessibleNode child);
          void insertBefore(AccessibleNode child, AccessibleNode before);
          void insertAfter(AccessibleNode child, AccessibleNode after);
          void removeChild(AccessibleNode child);
        };

        interface AccessibleDOMNode : AccessibleNode {
          readonly attribute Node node;
        };
        </pre>
        <p>
          The AccessibleNode constructor, when called, returns a new
          empty AccessibleNode object with its role initialized to
          the provided value. The AccessibleNode has no associated
          DOM Node and is not attached to the document's accessibility
          tree, it must be explicitly added as a child of another
          AccessibilityNode.
        </p>
        <p id="source">
          Let an AccessibleNode's <dfn>source</dfn> be an internal
          dictionary containing attributes that the author has set.
          Attributes in an AccessibleNode's <em>source</em>, when valid,
          supercede all other rules in the computation of that attribute.
        </p>
        <p>
          The <dfn>role</dfn> attribute, on setting, stores the provided
          DOMString in the AccessibleNode's <dfn>source</dfn>.
          On getting, it runs the following algorithm:
          <ul>
            <li>If the AccessibleNode's source contains a valid <dfn>role</dfn>
              according to the [[!WAI-ARIA]] spec, return that role.
            <li>Otherwise, if this is an AccessibleDOMNode and its associated
              DOM node has a valid <dfn>role</dfn> attribute according to the
              [[!WAI-ARIA]] spec, return that role.
            <li>Otherwise, if this is an AccessibleDOMNode, return the
              <dfn>computed role</dfn> for this node according to the
              [[!HTML-AAM-1.0]] spec.
            <li>Otherwise, return the empty string.
          </ul>
        </p>
        <p>
          The <dfn>setAttribute</dfn> method, when called with the
          name of an <a href="#attribute">accessibility attribute</a>,
          stores the provided value in the AccessibleNode's
          <a href="#source">source</a>.
        </p>
        <p>
          The <dfn>getAttribute</dfn> method, when called with the
          name of an <a href="#attribute">accessibility attribute</a>,
          runs the following algorithm:
          <ul>
            <li>If this attribute is not defined for the AccessibleNode's
              <dfn>role</dfn>, return <code>undefined</code>.
            <li>If the AccessibleNode's source contains a valid value
              for this attribute, returns that value.
            <li>Otherwise, if this is an AccessibleDOMNode, return the
              computed value of this attribute according to the
              algorithm associated with this attribute.
            <li>Otherwise, return the default value for this
              attribute, which may be <code>undefined</code>.
          </ul>
        </p>
        <p>
          For each supported <a href="#attribute">accessibility
            attribute</a>, the following partial interface applies.
          <pre>
            partial interface AccessibleNode {
            attribute <em>typename</em> attributeName;
            };</pre>
          Setting the attribute must invoke setAttribute() with the first
          argument being the attribute name, and the second argument the
          given value.  Getting the attribute must invoke getAttribute()
          with the argument being the attribute name, and return the result.
        </p>
        <p>
          The <dfn>parent</dfn> attribute must return the parent
          AccessibleNode in the accessibility tree, if any,
          and <code>undefined</code> otherwise.
        </p>
        <p>
          The <dfn>firstChild</dfn> attribute must return the
          AccessibleNode for the first child in the accessibility tree,
          if any, and <code>undefined</code> otherwise.
        </p>
        <p>
          The <dfn>lastChild</dfn> attribute must return the
          AccessibleNode for the last child in the accessibility tree,
          if any, and <code>undefined</code> otherwise.
        </p>
        <p>
          The <dfn>nextSibling</dfn> attribute must return the
          AccessibleNode for the next sibling in the accessibility tree,
          if any, and <code>undefined</code> otherwise.
        </p>
        <p>
          The <dfn>previousSibling</dfn> attribute must return the
          AccessibleNode for the previous sibling in the accessibility tree,
          if any, and <code>undefined</code> otherwise.
        </p>
        <p>
          The <dfn>appendChild</dfn> method, when called with a valid
          AccessibleNode argument, detaches the provided AccessibleNode
          from its previous parent, if any, and appends it to the end of
          the list of children in the accessibility tree.
        </p>
        <p>
          The <dfn>insertBefore</dfn> method, when called with a valid
          AccessibleNode argument <dfn>child</dfn> and a valid existing
          child of this accessible node <dfn>before</dfn>, detaches the
          provided AccessibleNode from its previous parent, if any, and
          inserts it into the list of children of this node immediately
          before <dfn>before</dfn>.
        </p>
        <p>
          The <dfn>insertAfter</dfn> method, when called with a valid
          AccessibleNode argument <dfn>child</dfn> and a valid existing
          child of this accessible node <dfn>after</dfn>, detaches the
          provided AccessibleNode from its previous parent, if any, and
          inserts it into the list of children of this node immediately
          after <dfn>after</dfn>.
        </p>
        <p>
          The <dfn>removeChild</dfn> method, when called with a valid
          AccessibleNode argument <dfn>child</dfn> corresponding to an
          existing child of this accessible node, removes that node
          as one of this node's children. The previous child is now
          detached and not part of the accessibility tree.
        </p>
        <p class="note">
          Calling appendChild, insertBefore, insertAfter, or removeChild
          only affects the accessibility tree and never the DOM tree.
        </p>
      </section>
    </section>

    <section>
      <h2>
        Accessibility attributes
      </h2>
      <p>
        An <dfn>Accessibility Attribute</dfn> is an abstract concept that is not
        exposed as an object in the DOM. An Accessibility Attribute has
        the following associated properties:
      </p>
      <dl>
        <dt>name</dt>
        <dd>The name of the attribute.</dd>
        <dt>type</dt>
        <dd>The data type that values of this attribute take</dd>
        <dt>settable</dt>
        <dd>Whether this value can be set on an AccessibleNode or
          if it's read-only.</dd>
        <dt>supported roles</dt>
        <dd>A list of roles on which this attribute is allowed to be set</dd>
        <dt>related ARIA attribute</dt>
        <dd>The corresponding ARIA attributes, if any</dd>
        <dt>computed value algorithm</dt>
        <dd>The algorithm used to compute the value of this attribute,
          when not explicitly set on an AccessibleNode./dd>
      </dl>
      <p>
        AccessibleNodes support the following accessibility attributes:
      </p>
      <table>
        <caption>
          Accessibility attribute table
        </caption>
        <thead>
          <tr>
            <th>attribute name</th>
            <th>type</th>
            <th>default value</th>
            <th>settable</th>
            <th>supported roles</th>
            <th>related ARIA attributes</th>
            <th>computed value algorithm</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>activeDescendant</code></td>
            <td><code>AccessibleNode?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-activedescendant</nobr></code></td>
            <td><code><nobr>aria-activedescendant</nobr></code></td>
            <td>
              The element referenced by
              <code><nobr>aria-activedescendant</nobr></code>, if any,
              otherwise the active option of a
              HTMLSelectElement, if any, otherwise
              <code>undefined</code>.
            </td>
          </tr>
          <tr>
            <td><code>autocomplete</code></td>
            <td><code>enum { "both", "inline", "list", "none" }</code></td>
            <td><code>"none"</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-autocomplete</nobr></code></td>
            <td><code><nobr>aria-autocomplete</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>colCount</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-colcount</nobr></code></td>
            <td><code><nobr>aria-colcount</nobr></code></td>
            <td>
              The value of <code><nobr>aria-colcount</nobr></code>,
              if any, otherwise the number of columns
              in a HTMLTableElement.
            </td>
          </tr>
          <tr>
            <td><code>colIndex</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-colindex</nobr></code></td>
            <td><code><nobr>aria-colindex</nobr></code></td>
            <td>
              The value of <code><nobr>aria-colindex</nobr></code>,
              if any, otherwise the index of the current
              column for any element with a cell role.
            </td>
          </tr>
          <tr>
            <td><code>colSpan</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-colspan</nobr></code></td>
            <td><code><nobr>aria-colSpan</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>controls</code></td>
            <td><code>iterable&lt;AccessibleNode&gt;</code></td>
            <td><code>[]</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-controls</nobr></code></td>
            <td><code><nobr>aria-controls</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>describedBy</code></td>
            <td><code>iterable&lt;AccessibleNode&gt;</code></td>
            <td><code>[]</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td><code><nobr>aria-describedby</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>description</code></td>
            <td><code>DOMString</code></td>
            <td><code>""</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td>
              <code><nobr>aria-describedby</nobr></code>
            </td>
            <td>
              The accessible description computation algorithm
              as defined in [[!ACCNAME-AAM-1.1]].
            </td>
          </tr>
          <tr>
            <td><code>disabled</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-disabled</nobr></code></td>
            <td><code><nobr>aria-disabled</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>expanded</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-expanded</nobr></code></td>
            <td><code><nobr>aria-expanded</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>focusable</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td>
              Returns true if an AccessibleDOMNode's associated
              DOM node is focusable.
            </td>
          </tr>
          <tr>
            <td><code>focused</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>readonly</td>
            <td><em>all roles</em></td>
            <td></td>
            <td>
              Returns true if an AccessibleNode is currently
              focused. Note that it's possible for this to not
              correspond to the DOM Node with input focus.
            </td>
          </tr>
          <tr>
            <td><code>hasPopUp</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-haspopup</nobr></code></td>
            <td><code><nobr>aria-haspopup</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>invalid</code></td>
            <td><code>enum { "grammar", "false", "spelling", "true" }</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-invalid</nobr></code></td>
            <td><code><nobr>aria-invalid</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>label</code></td>
            <td><code>DOMString</code></td>
            <td><code>""</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td>
              <code><nobr>aria-label</nobr></code>,
              <code><nobr>aria-labelledby</nobr></code>
            </td>
            <td>
              The accessible name computation algorithm
              as defined in [[!ACCNAME-AAM-1.1]].
            </td>
          </tr>
          <tr>
            <td><code>labelledBy</code></td>
            <td><code>iterable&lt;AccessibleNode&gt;</code></td>
            <td><code>[]</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td><code><nobr>aria-labelledby</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>level</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-level</nobr></code></td>
            <td><code><nobr>aria-level</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>multiselectable</code></td>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-multiselectable</nobr></code></td>
            <td><code><nobr>aria-multiselectable</nobr></code></td>
            <td>
              Returns true if
              <code><nobr>aria-multiselectable</nobr></code> is set to true,
              or for an HTML <code>select</code> element with
              the <code>multi</code> attribute set.
            </td>
          </tr>
          <tr>
            <td><code>offsetParent</code></td>
            <td><code>AccessibleNode?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetLeft</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetTop</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetWidth</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>offsetHeight</code></td>
            <td><code>long</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>orientation</code></td>
            <td><code>enum { "horizontal", "vertical" } | undefined</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-orientation</nobr></code></td>
            <td><code><nobr>aria-orientation</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>placeholder</code></td>
            <td><code>DOMString?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-placeholder</nobr></code></td>
            <td><code><nobr>aria-placeholder</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>posInSet</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-posinset</nobr></code></td>
            <td><code><nobr>aria-posinset</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rangeValue</code></td>
            <td><code>double?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rangevalue</nobr></code></td>
            <td><code><nobr>aria-rangevalue</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rangeMin</code></td>
            <td><code>double?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rangemin</nobr></code></td>
            <td><code><nobr>aria-rangemin</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rangeMax</code></td>
            <td><code>double?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rangemax</nobr></code></td>
            <td><code><nobr>aria-rangemax</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>readonly</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-readonly</nobr></code></td>
            <td><code><nobr>aria-readonly</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>required</code></td>
            <td><code>boolean?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-required</nobr></code></td>
            <td><code><nobr>aria-required</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rowCount</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rowcount</nobr></code></td>
            <td><code><nobr>aria-rowcount</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rowIndex</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rowindex</nobr></code></td>
            <td><code><nobr>aria-rowindex</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>rowSpan</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-rowspan</nobr></code></td>
            <td><code><nobr>aria-rowspan</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>setSize</code></td>
            <td><code>long?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-setsize</nobr></code></td>
            <td><code><nobr>aria-setsize</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollable</code></td>
            <td><code>boolean</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollX</code></td>
            <td><code>double</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollXMin</code></td>
            <td><code>double</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollXMax</code></td>
            <td><code>double</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollY</code></td>
            <td><code>double</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollYMin</code></td>
            <td><code>double</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>scrollYMax</code></td>
            <td><code>double</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>sort</code></td>
            <td><code>enum { "ascending", "descending", "none", "other" }</code></td>
            <td><code>"none"</code></td>
            <td>settable</td>
            <td>same as <code><nobr>aria-sort</nobr></code></td>
            <td><code><nobr>aria-sort</nobr></code></td>
            <td></td>
          </tr>
          <tr>
            <td><code>value</code></td>
            <td><code>DOMString?</code></td>
            <td><code>undefined</code></td>
            <td>settable</td>
            <td><em>all widget roles</em></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>visible</code></td>
            <td><code>boolean</code></td>
            <td><code>true</code></td>
            <td>readonly</td>
            <td><em>all roles</em></td>
            <td>
              <code><nobr>aria-hidden</nobr></code>
            </td>
            <td>
              Returns true if an AccessibleDOMNode is not part of
              the accessibility tree because the DOM node is not
              visible or not displayed, or because the DOM node has
              the <code><nobr>aria-hidden</nobr></code> attribute set.
            </td>
          </tr>
        </tbody>
      </table>
      <section>
        <h3>
          Accessible names and descriptions
        </h3>
        <p>
          In web accessibility, every node in the accessibility
          tree has an <dfn>accessible name</dfn> and
          <dfn>accessible description</dfn>, which are computed
          using the algorithm described in [[!ACCNAME-AAM-1.1]].
          The name is primary, the description is secondary.
        </p>
        <p>
          There are many possible sources of the accessible name
          of an element from its declarative markup. As an example,
          an HTML INPUT element may get its accessible name from
          an associated LABEL element, from the <code>title</code>
          attribute, from the <code>aria-label</code>
          attribute, from the <code>aria-labelledby</code>
          attribute, or more. The [[!ACCNAME-AAM-1.1]] algorithm
          specifies exactly how these combine to form the final
          accessible name.
        </p>
        <p>
          When using the AccessibleNode interface, it's much simpler.
          The <code>label</code> attribute contains the accessible
          name and the <code>description</code> attribute contains
          the accessible description. In addition, the
          <code>labelledBy</code> attribute contains references to
          other accessible nodes that provided the label for a node,
          and the <code>describedBy</code> attribute contains
          references to other accessible nodes that provided
          the description, but those relation attributes are
          informational only.
        </p>
        <p>
          In particular, setting an AccessibleNode's
          <code>labelledBy</code> or <code>describedBy</code>
          attributes will have <em>no effect</em> on its
          accessible name or description. Set the
          <code>label</code> and <code>description</code>
          attributes directly if you want those to change.
        </p>
      </section>
      <section>
        <h3>
          Relation attributes
        </h3>
        <p>
          Some accessibility attributes express a relationship between
          one accessible node and another, just like their ARIA
          counterparts. Unlike their ARIA counterparts, the nodes
          referenced by these attributes do not need to have a unique
          ID. A relationship may be expressed between any two nodes
          whose <dfn>ancestor Documents</dfn> have the same origin.
          This it is possible to express a relationship between
          a node in the main frame and a node in a child frame, or
          between a node in one element's shadow root and a different
          node in another element's shadow root, to name two specific
          examples.
        </p>
      </section>
      <section>
        <h3>
          Attributes deferred for a future version
        </h3>
        <p>
          The following were considered as possible accessibility
          attributes but were deferred for a future version of the
          spec. Please file a bug if you have a compelling use case
          for one of these.
        </p>
        <ul>
          <li><code>checked</code>
          <li><code>current</code>
          <li><code>details</code>
          <li><code>errorMessage</code>
          <li><code>flowTo</code>
          <li><code>keyboardShortcuts</code>
          <li><code>liveAtomic</code>
          <li><code>liveBusy</code>
          <li><code>liveRelevant</code>
          <li><code>liveStatus</code>
          <li><code>modal</code>
          <li><code>multiline</code>
          <li><code>offscreen</code>
          <li><code>pressed</code>
          <li><code>roleDescription</code>
          <li><code>text</code>
        </uL>
      </section>
      <section>
        <h3>
          Accessibility input events
        </h3>
        <p>
          All AccessibilityNodes are EventTargets, so authors
          can register event listeners on them. AccessibilityNodes
          receive special <dfn>accessibility input events</dfn>
          that represent explicit intents to control the user agent
          via an accessibility API
        </p>
        <p>
          Accessibility input events are needed for two reasons.
          First, because it's possible to create AccessibleNodes
          that don't correspond to a DOM node and authors need to
          be able to listen to events on these nodes. Second,
          because there are many types of specific user intents
          that can be communicated to the user agent via accessibility
          APIs that don't correspond to existing keyboard and mouse
          events - for example some assistive technology has
          keystrokes or gestures to increment a slider, or dismiss
          a pop-up.
        </p>
        <pre class="idl">
          interface AccessibleInputEvent : Event {
          };
          interface AccessibleSetValueEvent : AccessibleInputEvent {
          DOMString value;
          };
        </pre>
        <table>
          <caption>
            Accessibility event table
          </caption>
          <thead>
            <tr>
              <th>event name</th>
              <th>type</th>
              <th>valid roles</th>
              <th>fallback behavior</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>"accessibleclick"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>Fire <code>"click"</code> event on DOM node</td>
            </tr>
            <tr>
              <td><code>"accessiblesetvalue"</code></td>
              <td><code>AccessibleSetValueEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>Change value of INPUT or TEXTAREA element</td>
            </tr>
            <tr>
              <td><code>"accessibleincrement"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>
                Change value of INPUT type="range",
                otherwise fire <code>"keypress"</code> with a
                RightArrow key code
              </td>
            </tr>
            <tr>
              <td><code>"accessibledecrement"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"scrollbar"</code>,
                <code>"slider"</code>
              </td>
              <td>
                Change value of INPUT type="range",
                otherwise fire <code>"keypress"</code> with a
                LeftArrow key code
              </td>
            </tr>
            <tr>
              <td><code>"accessibleselect"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td>
                <code>"cell"</code>,
                <code>"option"</code>
              </td>
              <td>
                Change selectedIndex of SELECT
                otherwise fire <code>"click"</code> event
              </td>
            </tr>
            <tr>
              <td><code>"accessiblescrollintoview"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>scroll DOM node into view</td>
            </tr>
            <tr>
              <td><code>"accessibledismiss"</code></td>
              <td><code>AccessibleInputEvent</code></td>
              <td><em>all roles</em></td>
              <td>fire <code>"keypress"</code> with a
                Escape key code</td>
            </tr>
          </tbody>
        </table>
        <p>
          Accessibility input events go through capture and bubble
          phases, just like DOM events. The only difference is that
          the capture and bubble phases happen entirely in the
          accessibility tree. If the event is not canceled
          (by calling <code>preventDefault()</code> after completely
          going through the capture and bubble phases in the accessibility
          tree, the event executes its <dfn>fallback behavior</dfn>,
          as defined in the table above.
        </p>
        <p>
          When an event's fallback behavior involves firing a DOM
          event, the event's target will be the associated DOM node
          of the target AccessibleNode, or the associated DOM node
          of the nearest ancestor of the target AccessibleNode that
          has one. Fallback DOM events will go through capture and
          bubble phases just like any other DOM events.
        </p>
        <p>
          As an example, suppose an accessible click event is received
          on a button. Here's the sequence of what will occur:
          <ol>
            <li>Capturing event listeners are called, starting with the
              root of the accessibility tree, and continuing along the
              ancestor chain until reaching the target AccessibleNode in
              the accessibility tree.
            <li>If none of the capturing event listeners stop
              propagation, normal (non-capturing) event listeners on the
              target AccessibleNode are called, and if
              <code>stopPropagation()</code> is not called, the event
              bubbles up to all event listeners on ancestors of the
              target.
            <li>After capture and bubble phases in the accessibility tree,
              if <code>preventDefault()</code> was not called, the
              event's <dfn>fallback behavior</dfn> is triggered. In this
              case it fires a DOM <code>"click"</code> event on the
              targer AccessibleNode's associated DOM node, going through
              capture and bubble phases in the DOM tree.
          </ol>
        </p>
      </section>
    </section>
    <section class='appendix'>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many thanks for valuable feedback, advice, and tools from:
        Robin Berjon, Marcos Caceres, Nan Wang, Ian Hickson, and Domenic Denicola.
      </p>
    </section>
  </body>
</html>
